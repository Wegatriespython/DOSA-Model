*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/bounds.gms

vm_cesIO.fx(t0,regi_dyn29(regi),in_industry_dyn37(in))$( 
                                              NOT sameas(in,"en_otherInd_hth") )
  = pm_cesdata(t0,regi,in,"quantity");

*' Reduce the lower limit on the CES function to accommodate less utilised
*' production factors in (energetically) small regions.  (Example: gas heating
*' in Sub-Sahara Africa -- SSA/enhgab).
if (smax((t,regi_dyn29(regi),ipf)$(    t.val gt 2005
                                   AND NOT ue_industry_dyn37(ipf) ),
      vm_cesIO.lo(t,regi,ipf)
    - (0.95 * pm_cesdata(t,regi,ipf,"quantity"))) gt 0,

  put logfile, ">>> Modifyipfg vm_cesIO lower bounds <<<" /;
  loop ((regi_dyn29(regi),ipf,t)$(    t.val gt 2005
                                  AND NOT ue_industry_dyn37(ipf) ),
    if (vm_cesIO.lo(t,regi,ipf) gt 0.95 * pm_cesdata(t,regi,ipf,"quantity"),
      put "vm_cesIO.lo(", t.tl, ",", regi.tl, ",", ipf.tl, ")   ";
      put vm_cesIO.lo(t,regi,ipf), " -> ";
      put (0.95 * pm_cesdata(t,regi,ipf,"quantity")) /;

      vm_cesIO.lo(t,regi,ipf)
      = min(
          vm_cesIO.lo(t,regi,ipf),
          ( pm_cesdata(t,regi,ipf,"quantity")
          * 0.95
          ));
    );
  );

  putclose logfile, " " /;
);

*' relax industry fixing over the calibration iterations
sm_tmp = 5;  !! last iteration with bounds on industry
loop (pf_industry_relaxed_bounds_dyn37(in),
  vm_cesIO.lo(t_29(t),regi_dyn29(regi),in)
  = max(
      ( pm_cesdata(t,regi,in,"quantity")
        !! goes from 0.95 to 1e-12 in -0.2 steps
      * max(1e-12, 0.95 + min(0, (1 - sm_CES_calibration_iteration) / sm_tmp))
      ),
      abs(pm_cesdata(t,regi,in,"offset_quantity"))
    );

  vm_cesIO.up(t,regi_dyn29(regi),in)
  = ( pm_cesdata(t,regi,in,"quantity")
    !! goes from 1.05 to 2.05 in +0.2 steps, then jumps to inf
    * (1.05 + max(0, (sm_CES_calibration_iteration - 1) / sm_tmp))
    )$( sm_CES_calibration_iteration le sm_tmp )
  + INF$( sm_CES_calibration_iteration gt sm_tmp );
);

*** EOF ./modules/29_CES_parameters/calibrate/bounds.gms

*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/datainput.gms

*** Set dynamic regional set depending on testOneRegi
$ifthen "%optimization%" == "testOneRegi"
regi_dyn29(all_regi) = regi_dyn80(all_regi);
$else
regi_dyn29(all_regi) = regi(all_regi);
$endif


*** Core substitution elasticities
Parameter
  p29_cesdata_sigma(all_in) "substitution elasticities"
  /
    inco        0.5
      en        0.3
  /
;

pm_cesdata_sigma(ttot,in)$p29_cesdata_sigma(in) = p29_cesdata_sigma(in);

pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) le 2025  AND sameAs(in, "inco")) = 0.1;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2030  AND sameAs(in, "inco")) = 0.15;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2035  AND sameAs(in, "inco")) = 0.20;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2040  AND sameAs(in, "inco")) = 0.30;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2045  AND sameAs(in, "inco")) = 0.40;

pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) le 2025  AND sameAs(in, "en")) = 0.1;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2030  AND sameAs(in, "en")) = 0.12;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2035  AND sameAs(in, "en")) = 0.15;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2040  AND sameAs(in, "en")) = 0.20;
pm_cesdata_sigma(ttot,in)$ (pm_ttot_val(ttot) eq 2045  AND sameAs(in, "en")) = 0.25;



*** Specify the ces structure on which the calibration will run.
ppf_29(all_in)
  = ppfen_dyn35(all_in)
  + cal_ppf_buildings_dyn36(all_in)
  + cal_ppf_industry_dyn37(all_in)
  + industry_ue_calibration_target_dyn37(all_in)
;

ppf_29("kap") = YES;
ppf_29("lab") = YES;

*** Useful energy
ue_29(all_in)
  = ue_dyn36(all_in)                               !! Buildings
  + industry_ue_calibration_target_dyn37(all_in)   !! Industry
;

*** Fill the sets that need special treatment of efficiencies beyond calib
ue_fe_kap_29(in) = NO;

loop (ue_29(ppf_29(out)),
  sm_tmp  = 0;
  sm_tmp2 = 0;

  loop (cesOut2cesIn(out,in),
    if (ppfKap(in), sm_tmp  = sm_tmp  + 1);
    if (ppfEn(in),  sm_tmp2 = sm_tmp2 + 1);
  );

  !! in case one input is ppfEn/FE and the other Kap
  if (sm_tmp eq 1 AND sm_tmp2 eq 1,
    ue_fe_kap_29(out) = YES;
  else
     sm_tmp = 0;
     loop (cesOut2cesIn(out,in),
       sm_tmp = sm_tmp +1;
     );
  );
);

*** Remove sets from ue_fe_kap_29 that receive special treatment
loop (cesOut2cesIn(out,in)$(   pf_eff_target_dyn29(in)
                            OR pf_quan_target_dyn29(in) ),
  ue_fe_kap_29(out) = NO;
);

*** Compute the internal sets for the calibration of the CES

*** First, take the maximum level of ppf_29
sm_tmp = 0
loop(cesLevel2cesIO(counter,ppf_29(in)),
  if (counter.val gt sm_tmp,
    sm_tmp = counter.val;
  );
);

*** Second, all ppf_29 are part of in_29
in_29(ppf_29) = YES

*** Third, include recursively all "out" of ppf_29 in in_29
for (sm_tmp = sm_tmp downto 0,
  loop ((counter,cesOut2cesIn(out,in))$( counter.val eq sm_tmp AND in_29(in)),
    in_29(out) = YES;
  )
);

*** Fourth, calculate intermediate production factors
ipf_29(all_in) = in_29(all_in) - ppf_29(all_in);

ces_29(out,in_29) = cesOut2cesIn(out,in_29);

ppf_beyondcalib_29(all_in) = NO;
ipf_beyond_29(all_in) = NO;

ppf_beyondcalib_29(all_in) = in(all_in) - in_29(all_in);

loop (cesOut2cesIn(out,ppf_beyondcalib_29(in)),
  ipf_beyond_29(out) = YES;
);
ipf_beyond_29_excludeRoot(ipf_beyond_29) = YES;
ipf_beyond_29_excludeRoot(ppf_29) = NO;

in_beyond_calib_29(all_in)
  = ipf_beyond_29(all_in)
  + ppf_beyondcalib_29(all_in);

in_beyond_calib_29_excludeRoot(in_beyond_calib_29) = YES;
in_beyond_calib_29_excludeRoot(ppf_29) = NO;

root_beyond_calib_29(in_beyond_calib_29)$ppf_29(in_beyond_calib_29) = YES;

ces_beyondcalib_29(ipf_beyond_29,in)   = cesOut2cesIn(ipf_beyond_29,in);

ces2_29(out,in) = ces_29(out,in);
ces2_beyondcalib_29(out,in) = ces_beyondcalib_29(out,in);
alias(ipf_29,ipf2_29);

ipf_beyond_last(all_in) = NO;
loop (cesOut2cesIn(out,in)$(in_beyond_calib_29(in) AND ppf(in)),
ipf_beyond_last(out) = YES;
);

*** End of Sets calculation

Parameter
p29_trpdemand       "transport demand"
/
$ondelim
$include "./modules/29_CES_parameters/calibrate/input/f29_trpdemand.cs4r"
$offdelim
/

parameter
f29_capitalQuantity(tall,all_regi,all_demScen,all_in)          "capital quantities"
/
$ondelim
$include "./modules/29_CES_parameters/calibrate/input/f29_capitalQuantity.cs4r"
$offdelim
/
;
p29_capitalQuantity(t,regi,ppfKap) = f29_capitalQuantity(t,regi,"%cm_GDPscen%",ppfKap);

*** fix industry energy efficiency capital for mrremind rounding
loop ((ttot,regi,ppfKap_industry_dyn37(in))$( t(ttot-1) AND t(ttot+1) ),
  sm_tmp
  = p29_capitalQuantity(ttot-1,regi,in)
  * ( (1 - pm_delta_kap(regi,in))
   ** (pm_ttot_val(ttot) - pm_ttot_val(ttot-1))
    );

  if (p29_capitalQuantity(ttot,regi,in) lt sm_tmp,
    p29_capitalQuantity(ttot,regi,in)
    = ( p29_capitalQuantity(ttot-1,regi,in)
      + p29_capitalQuantity(ttot+1,regi,in)
      )
    / 2;
  );
);

display pm_fedemand;

*** setting feh2i equal to 1% of fegai
$ifthen.indst_H2_penetration "%industry%" == "fixed_shares"
pm_fedemand(t,regi,"feh2i")$(t.val ge 2010) = 0.01*pm_fedemand(t,regi,"fegai");
$endif.indst_H2_penetration

display pm_fedemand;

*** Change PPP for MER.
p29_capitalQuantity(tall,all_regi,all_in)
 = p29_capitalQuantity(tall,all_regi,all_in)
 * pm_shPPPMER(all_regi);

*** Subtract "special" capital stocks from gross economy capital stock
p29_capitalQuantity(tall,all_regi,"kap")
  = p29_capitalQuantity(tall,all_regi,"kap")
  - sum(ppfKap(in)$( NOT sameAs(in,"kap")),
      p29_capitalQuantity(tall,all_regi,in)
    );

*** Substract the end-use capital quantities from the aggregate capital

*** Load CES parameters from the last run
Execute_Load 'input'  p29_cesdata_load = pm_cesdata;
$ifthen.testOneRegi "%optimization%" == "testOneRegi"   !! optimization
  !! carry along CES parameters for other regions in testOneRegi runs
  pm_cesdata(t,regi,in,cesParameter)$( NOT regi_dyn29(regi) )
  = p29_cesdata_load(t,regi,in,cesParameter);
$endif.testOneRegi

*** FS: if some elasticities are 0 because they are not part of the input gdx, -> set them to 0.5 to avoid divsion by 0
p29_cesdata_load(t,regi,in,"rho")$( p29_cesdata_load(t,regi,in,"rho") eq 0) = 0.5;

*** Load quantities and efficiency growth from the last run
Execute_Loadpoint 'input'  p29_cesIO_load = vm_cesIO.l, p29_effGr = vm_effGr.l;

Execute_Loadpoint 'input' vm_deltaCap;

*** Load exogenous Labour, GDP
pm_cesdata(t,regi,"inco","quantity") = pm_gdp(t,regi);
pm_cesdata(t,regi,"lab","quantity") = pm_lab(t,regi);
*** Load exogenous FE trajectories
*** Change EJ to TWa

pm_cesdata(t,regi,in,"quantity")$(pm_fedemand(t,regi,in)) =
$ifthen.industry_subsectors "%industry%" == "subsectors"
  pm_fedemand(t,regi,in)$(industry_ue_calibration_target_dyn37(in))
  +
  sm_EJ_2_TWa * pm_fedemand(t,regi,in)$(NOT industry_ue_calibration_target_dyn37(in));
$else.industry_subsectors
  sm_EJ_2_TWa * pm_fedemand(t,regi,in)
$endif.industry_subsectors

*** Load exogenous transport demand - required for the EDGE transport module
$ifthen.edgesm %transport% ==  "edge_esm"
pm_cesdata(t,regi,in,"quantity") $ p29_trpdemand(t,regi,"%cm_GDPscen%","%cm_demScen%","%cm_EDGEtr_scen%", in)
           = p29_trpdemand(t,regi,"%cm_GDPscen%","%cm_demScen%","%cm_EDGEtr_scen%", in);
$endif.edgesm

*** Load capital quantities
pm_cesdata(t,regi,ppfKap,"quantity") = p29_capitalQuantity(t,regi,ppfKap);

$ifthen.subsectors "%industry%" == "subsectors"
*** Assume fehe_otherInd at 0.1% of fega_otherInd for regions with zero
*** fehe_otherInd in historic periods (IND, LAM, MEA, SSA)
loop ((t_29hist(t),regi_dyn29(regi))$(
                           pm_cesdata(t,regi,"fehe_otherInd","quantity") eq 0 ),
  pm_cesdata(t,regi,"fehe_otherInd","quantity")
  = 1e-4
  * pm_cesdata(t,regi,"fega_otherInd","quantity");

  pm_cesdata(t,regi,"fehe_otherInd","offset_quantity")
  = -pm_cesdata(t,regi,"fehe_otherInd","quantity");
);

*** Use offset quantity for regions with no production/energy use in certain
*** subsectors (e.g. no primary steel production in NEN)
loop ((t,regi_dyn29(regi)),
  loop (ue_industry_dyn37(out)$( pm_cesdata(t,regi,out,"quantity") eq 0 ),
    pm_cesdata(t,regi,out,"quantity") = 1e-6;
    pm_cesdata(t,regi,out,"offset_quantity")
    = -pm_cesdata(t,regi,out,"quantity");

    if (sum(ces_eff_target_dyn37(out,in), pm_cesdata(t,regi,in,"quantity")) eq 0,
      loop (ces_eff_target_dyn37(out,in),
        pm_cesdata(t,regi,in,"quantity") = 1e-6;
	pm_cesdata(t,regi,in,"offset_quantity")
	= -pm_cesdata(t,regi,in,"quantity");
      );
    );
  );
);

*** Use offset quantities for historic industry H2/HTH_el use, since it actually
*** did not happen.
loop (pf_quantity_shares_37(in,in2),
  pm_cesdata(t_29hist(t),regi_dyn29(regi),in,"offset_quantity")$(
                                  pm_cesdata(t,regi,in,"offset_quantity") eq 0 )
  = -pm_cesdata(t,regi,in,"quantity");
);
$endif.subsectors

$ifthen.indst_H2_offset "%industry%" == "fixed_shares"

*** Assuming feh2i minimun levels as 1% of fegai to avoid CES numerical calibration issues and allow more aligned efficiencies between gas and h2
loop ((t,regi)$(pm_cesdata(t,regi,"feh2i","quantity") lt (0.01 * pm_cesdata(t,regi,"fegai","quantity"))),
  pm_cesdata(t,regi,"feh2i","offset_quantity") = - (0.01 * pm_cesdata(t,regi,"fegai","quantity") - pm_cesdata(t,regi,"feh2i","quantity"));
  pm_cesdata(t,regi,"feh2i","quantity") = 0.01 * pm_cesdata(t,regi,"fegai","quantity");
);

*** Special treatment for fehei, which is part of ppfen_industry_dyn37, yet
*** needs an offset value for some regions under fixed_shares
loop ((t,regi)$(pm_cesdata(t,regi,"fehei","quantity") lt 1e-5 ),
  pm_cesdata(t,regi,"fehei","offset_quantity")  = pm_cesdata(t,regi,"fehei","quantity") - 1e-5;
  pm_cesdata(t,regi,"fehei","quantity") = 1e-5;
);
$endif.indst_H2_offset

$ifthen.build_H2_offset "%buildings%" == "simple"
*** Assuming feh2b minimun levels as 5% of fegab to avoid CES numerical calibration issues and allow more aligned efficiencies between gas and h2
*loop ((t,regi)$(pm_cesdata(t,regi,"feh2b","quantity") lt (0.05 *pm_cesdata(t,regi,"fegab","quantity"))),
*	pm_cesdata(t,regi,"feh2b","offset_quantity") = - (0.05 * pm_cesdata(t,regi,"fegab","quantity") - pm_cesdata(t,regi,"feh2b","quantity"));
*	pm_cesdata(t,regi,"feh2b","quantity") = 0.05 * pm_cesdata(t,regi,"fegab","quantity");
*);

*** RK: feh2b offset scaled from 1% in 2025 to 50% in 2050 of fegab quantity
loop ((t,regi),
	pm_cesdata(t,regi,"feh2b","offset_quantity")
  = - (0.05 + 0.45 * min(1, max(0, (t.val - 2025) / (2050 - 2025))))
      * pm_cesdata(t,regi,"fegab","quantity")
    - pm_cesdata(t,regi,"feh2b","quantity");
      pm_cesdata(t,regi,"feh2b","quantity")
  = (0.05 + 0.45 * min(1, max(0, (t.val - 2025) / (2050 - 2025))))
      * pm_cesdata(t,regi,"fegab","quantity");
);
$endif.build_H2_offset

*** Add an epsilon to the values which are 0 so that they can fit in the CES
*** function. And withdraw this epsilon when going to the ESM side
loop((t,regi,in)$(    (ppf(in) OR ppf_29(in))
                  AND pm_cesdata(t,regi,in,"quantity") lt 1e-5
                  AND NOT ppfen_industry_dyn37(in)
                  AND NOT ppfKap_industry_dyn37(in)
                  AND NOT SAMEAS(in,"feh2i")
                  AND NOT SAMEAS(in,"feh2b")        ),
  pm_cesdata(t,regi,in,"offset_quantity")  = pm_cesdata(t,regi,in,"quantity")  - 1e-5;
  pm_cesdata(t,regi,in,"quantity") = 1e-5;
);

*** Capital price assumption
p29_capitalPrice(t,regi) = 0.12;

*** Load capital price assumption for the first iteration, otherwise take it from gdx prices
if( sm_CES_calibration_iteration eq 1 AND s29_CES_calibration_new_structure eq 1,  pm_cesdata(t,regi,"kap","price") = p29_capitalPrice(t,regi));

p29_esubGrowth = 0.3;

*** EOF ./modules/29_CES_parameters/calibrate/datainput.gms
*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/declarations.gms

Scalars
  s29_CES_calibration_new_structure    "CES structure differs from input.gdx"  /%c_CES_calibration_new_structure%/
;

Parameters
  p29_CESderivative(tall,all_regi,all_in,all_in)   "derivative of the CES function for calculating prices"

  p29_alpha(all_regi,all_in)                       "XXX"
  p29_beta(all_regi,all_in)                        "XXX"
  p29_cesdata_load(tall,all_regi,all_in,cesParameter)  "pm_cesdata from the gdx file"
  p29_cesIO_load(tall,all_regi,all_in)                "production factor vm_cesIO from input.gdx"
  p29_effGr(tall,all_regi,all_in)                                   "growth of factor efficiency from input.gdx"
  p29_trpdemand(tall,all_regi,all_GDPscen,all_demScen,EDGE_scenario_all,all_in) "transport demand for the edge_esm transport module, unit: trillion passenger/ton km"
  p29_efficiency_growth(tall,all_regi,all_in)         "efficency level paths for ppf beyond calibration"
  p29_capitalQuantity(tall,all_regi,all_in)            "capital quantities"
  p29_capitalPrice(tall,all_regi)                "capital prices"

  p29_test_CES_recursive(tall,all_regi,all_in)      "test the technological consistency of pm_cesdata"

  p29_esubGrowth         "long term growth of the elasticity of substitution"

  p29_t_tmp(tall)                                       "tmp value for calculations over t"

  p29_share_H2HTH_traj_indst(ttot,all_regi,all_in)  "H2 and electricity HTH baseline trajectories as share of gas (for H2) and low-temperature electricity (for HTH electricity) trajectories in industry"
;

*** Load calibration iteration number from environment variable
*** cm_CES_calibration_iteration
put_utility "shell" / "exit $cm_CES_calibration_iteration";
sm_CES_calibration_iteration = errorlevel;
if (sm_CES_calibration_iteration lt 1,
  abort "sm_CES_calibration_iteration is zero.  Is cm_CES_calibration_iteration unset?";
);

file file_CES_calibration / "CES_calibration.csv" /;

file_CES_calibration.ap =     1;   !! append to file
file_CES_calibration.pc =     5;   !! csv file
file_CES_calibration.lw =     0;   !! no label padding
file_CES_calibration.nr =     2;   !! scientific notation
file_CES_calibration.nd =     3;   !! three decimal places
file_CES_calibration.nw =    10;   !! number width: +0.000e+00
file_CES_calibration.pw = 32767;   !! page width

$macro file_CES_calibration_integers \
  file_CES_calibration.nd = 0; \
  file_CES_calibration.nr = 1; \
  file_CES_calibration.nw = 0;

$macro file_CES_calibration_floats \
  file_CES_calibration.nd =  3; \
  file_CES_calibration.nr =  2; \
  file_CES_calibration.nw = 10;


if (sm_CES_calibration_iteration eq 1,
  !! print a comment header giving the order of production factors in the CES
  !! tree so that they can be displayed in a meaningful order in calibration
  !! reports
  file_CES_calibration.pc =  0;   !! text file
  put file_CES_calibration;

  CES_tc("inco") = YES;
  put "# pf order: inco";

  loop (cesOut2cesIn(out,in),
    CES_tp(out) = YES;
    CES_tp(in) = YES;
  );

  !! as long as there are nodes pending
  while (0 lt card(CES_tp),
    !! if the current node is a calibration target and all of its child nodes
    !! are pending (so it has not been processed before)
    if (sum(CES_tc$(    (   ppf(CES_tc)
                         OR industry_ue_calibration_target_dyn37(CES_tc))
                    AND (   sum(cesOut2cesIn(CES_tc,in), 1)
                         eq sum(cesOut2cesIn(CES_tc,CES_tp), 1))
                   ), 1),
    !! add the current node to the list
    loop (CES_tc, put ", ", CES_tc.tl:0);
  );

  !! if no child nodes are pending
  if (0 eq sum(cesOut2cesIn(CES_tc,CES_tp), 1),
    !! remove current node from pending nodes
    CES_tp(CES_tc) = NO;
    !! set parent node as current node
    loop (cesOut2cesIn(out,CES_tc), CES_ts(out) = YES);
    CES_tc(all_in) = NO;
    CES_tc(CES_ts) = YES;
    CES_ts(all_in) = NO;

  !! if any child nodes are pending
  else
    !! set first pending child node as current node
    loop (cesOut2cesIn(CES_tc,CES_tp), CES_ts(CES_tp) = YES);
      CES_tc(all_in) = NO;
$offorder
      CES_tc(CES_ts)$( 1 eq ord(CES_ts) ) = YES;
$onorder
      CES_ts(all_in) = NO;
    );
  );
  put " " /;

  !! print the csv header
  file_CES_calibration.pc =  5;   !! csv file
  put "scenario", "iteration", "t", "regi", "variable", "pf", "value" /;
  putclose file_CES_calibration;
);


file capital_unit /"capital_unit.csv"/; !! file for the reporting of the ESUBs estimations

capital_unit.ap = 1; !!
capital_unit.pc =  5;
capital_unit.lw =  0;
capital_unit.nw = 15;
capital_unit.nd =  9;

if (sm_CES_calibration_iteration eq 1,
put capital_unit;
put "iteration","index","period","variable", "parameter","region","value" /;
putclose;
);
*** EOF ./modules/29_CES_parameters/calibrate/declarations.gms
*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/output.gms
p29_CESderivative(t,regi_dyn29(regi),cesOut2cesIn(out,in))$( vm_cesIO.l(t,regi,in) gt 0 )
  =
    pm_cesdata(t,regi,in,"xi")
  * pm_cesdata(t,regi,in,"eff")
  * vm_effGr.l(t,regi,in)

  * (vm_cesIO.l(t,regi,out)
     )
 ** (1 - pm_cesdata(t,regi,out,"rho"))

  * ( pm_cesdata(t,regi,in,"eff")
    * vm_effGr.l(t,regi,in)
    * (vm_cesIO.l(t,regi,in)
       )
    )
 ** (pm_cesdata(t,regi,out,"rho") - 1);
;

*** Propagate price down the CES tree
loop ((cesLevel2cesIO(counter,in),cesOut2cesIn(in,in2),cesOut2cesIn2(in2,in3)),
  p29_CESderivative(t,regi_dyn29(regi),"inco",in3)
  = p29_CESderivative(t,regi,"inco",in2)
  * p29_CESderivative(t,regi,in2,in3);
);

*** Prices of intermediate production factors are all 1
***p29_CESderivative(t,regi_dyn29(regi),in,ipf_29(in2))$( p29_CESderivative(t,regi,in,in2) ) = 1;

*** Transfer prices
pm_cesdata(t,regi_dyn29(regi),in,"price")
  = p29_CESderivative(t,regi,"inco",in);

  
put file_CES_calibration;


loop ((t,regi_dyn29(regi),in)$(   ppf_29(in) 
                               OR ppf_beyondcalib_29(in)
                               OR sameas(in,"inco")),
  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl;
  file_CES_calibration_floats
  put "efficiency", in.tl;
  put (pm_cesdata("2005",regi,in,"eff") * vm_effGr.l(t,regi,in)) /;

  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl;
  file_CES_calibration_floats
  put "efficiency growth", in.tl, vm_effGr.l(t,regi,in) /;

  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl, "xi";
  file_CES_calibration_floats
  put in.tl, pm_cesdata(t,regi,in,"xi") /;
);

loop ((t,regi_dyn29(regi),in)$( (   ppf_29(in) 
                                    OR ppf_beyondcalib_29(in)
                                    OR sameas(in,"inco"))     ),
  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl;
  file_CES_calibration_floats
  put "quantity", in.tl, vm_cesIO.l(t,regi,in) /;

  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl, "price";
  file_CES_calibration_floats
  put in.tl, pm_cesdata(t,regi,in,"price") /;

  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl;
  file_CES_calibration_floats
  put "total efficiency", in.tl;
  put sum(cesOut2cesIn(out,in),
        pm_cesdata(t,regi,in,"xi")
     ** (1 / pm_cesdata(t,regi,out,"rho"))
      * ( pm_cesdata("2005",regi,in,"eff")
        * vm_effGr.l(t,regi,in)
        )
      ) /;
);

loop ((ttot,regi_dyn29(regi),te_29_report),
  file_CES_calibration_integers
  put "%c_expname%", sm_CES_calibration_iteration, ttot.tl, regi.tl;
  file_CES_calibration_floats
  put "vm_deltaCap", te_29_report.tl;
  put sum(rlf,vm_deltaCap.L(ttot,regi,te_29_report,rlf)) /;
);

loop ((t,regi_dyn29(regi),in),
  if (vm_cesIO.lo(t,regi,in) ne 0,
    file_CES_calibration_integers
    put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl;
    file_CES_calibration_floats
    put "lower bound", in.tl, vm_cesIO.lo(t,regi,in) /;
  );

  if (vm_cesIO.up(t,regi,in) ne INF,
    file_CES_calibration_integers
    put "%c_expname%", sm_CES_calibration_iteration, t.tl, regi.tl;
    file_CES_calibration_floats
    put "upper bound", in.tl, vm_cesIO.up(t,regi,in) /;
  );
);

putclose file_CES_calibration;

*** EOF ./modules/29_CES_parameters/calibrate/output.gms
*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/preloop.gms
$OFForder


*** ==================================================================================
***
*** For a documentation of this file, see the goxygen documentation, chapter
***       CES parameters (29_CES_parameters) / Realizations / (A) Calibrate
***
*** For a practical calibration tutorial, see 12_Calibrating_CES_Parameters.md
*** in the tutorials folder
***
*** ==================================================================================


option pm_cesdata:4:3:1;
display "check sets production function 29", ces_29, in_29, ppf_29, ipf_29,
        ppf_beyondcalib_29, ipf_beyond_29;
display "check starting pm_cesdata", pm_cesdata;

*** Abort if new structure flag is not set but should be
$ifthen.old_structure %c_CES_calibration_new_structure% == "0"
Execute_Load 'input'  ces2_29=cesOut2cesIn;
sm_tmp = 0;
loop ( ces2_29(out,in)$( NOT cesOut2cesIn2(out,in) ), sm_tmp = 1);
loop (cesOut2cesIn2(out,in)$( NOT  ces2_29(out,in) ), sm_tmp = 1);
if (sm_tmp,
  execute_unload "abort.gdx";
  abort "CES structure does not match. Enable c_CES_calibration_new_structure";
);

Execute_Load 'input'  regi_29_load=regi;
sm_tmp = 0;
loop ( regi_29_load(regi2)$( NOT regi(regi2) ), sm_tmp = 1);
loop (regi(regi2)$( NOT  regi_29_load(regi2) ), sm_tmp = 1);
if (sm_tmp,
  execute_unload "abort.gdx";
  abort "Regional structure does not match. Enable c_CES_calibration_new_structure";
);
$endif.old_structure


***_____________________________START OF:  1 - CALCULATE PRICES _____________________________
*** In the first iteration with a changed CES structure, ppf prices are set to an initial default.
if( sm_CES_calibration_iteration eq 1 and s29_CES_calibration_new_structure eq 1,
  !! Set CES prices to the value specified by cm_CES_calibration_default_prices
  !! and abort if cm_CES_calibration_default_prices == 0
$ifthen.default_prices %cm_CES_calibration_default_prices% == "0"
    abort "Please set cm_CES_calibration_default_prices > 0 to get the calibration started";
$endif.default_prices
  pm_cesdata(t,regi,all_in,"price") = %cm_CES_calibration_default_prices%;

  pm_cesdata(t,regi,ipf_29,"price") = 1;

  pm_cesdata(t,regi,industry_ue_calibration_target_dyn37(in),"price")$(
                                            pm_cesdata(t,regi,in,"price") eq 1 )
    = %cm_CES_calibration_default_prices%;

else
  !! If not first iteration with unknown CES structure, compute ppf prices from CES derivatives loaded from file

  !! Compute prices of each node from CES derivatives of previous run:
  !! d(V_o)/d(V_i) = pi_i  = xi_i * eff_i * effGr_i * V_o**(1-rho_o)  *  (eff_i * effGr_i * V_i)**(rho_o-1)
  p29_CESderivative(t,regi_dyn29(regi),ces_29(out,in))$(p29_cesIO_load(t,regi,in))
    = p29_cesdata_load(t,regi,in,"xi")
    * p29_cesdata_load(t,regi,in,"eff")
    * p29_effGr(t,regi,in)
    * p29_cesIO_load(t,regi,out)

    ** (1 - p29_cesdata_load(t,regi,out,"rho"))

    * exp(
         log(
             p29_cesdata_load(t,regi,in,"eff")
           * p29_effGr(t,regi,in)
           * p29_cesIO_load(t,regi,in)
         )
       * (p29_cesdata_load(t,regi,out,"rho") - 1)
        );

  !! Propagate price down the CES tree to get prices in terms of inco,
  !! i.e. calc d(inco)/d(in) by applying the chain rule (product of node derivatives)
  !! Going down, iteratively compute each income derivative as product of all prices in branch above
  !! Ppf prices will later be used as: pm_cesdata(in,"price") = p29_CESderivative("inco",in).
  !! the rest is discarded.
  loop ((cesLevel2cesIO(counter,in),ces_29(in,in2),ces2_29(in2,in3)),
      !! in3 is the current node, in2 is the node above.
      p29_CESderivative(t,regi_dyn29(regi),"inco",in3) !!   d(inco)/d(in3)
      = p29_CESderivative(t,regi,"inco",in2)           !! = d(inco)/d(in2)
      * p29_CESderivative(t,regi,in2,in3);             !! * d(in2 )/d(in3)
  );


  !! Prices of intermediate production factors are all set to 1,
  !! To account for the chain rule multiplication above.
  loop ( cesOut2cesIn(in2,in),
    p29_CESderivative(t,regi_dyn29(regi),out,ipf_29(in2))$(
                                              p29_CESderivative(t,regi,out,in2) )
    = 1;
  );
  !! Price of inco is 1
  p29_cesdata_load(t,regi_dyn29(regi),"inco","price") = 1;   !! unit price

  !! Transfer prices
  pm_cesdata(t,regi_dyn29(regi), in, "price") =
  p29_CESderivative(t,regi,"inco",in);

  option
    p29_CESderivative:3:3:1
    pm_cesdata:3:3:1
  ;

  !! The calibration of elasticities of substitution takes
  !! much longer to converge if it starts from a high elasticity of
  !! substitution. To avoid this situation, the price of the capital stock
  !! is increased
  if (sm_CES_calibration_iteration eq 1,
    loop (cesOut2cesIn(out,in)$(pm_cesdata_sigma("2015",out) eq -1 AND ppfKap(in) AND in_29(in)),
        pm_cesdata(t,regi,in,"price") = pm_cesdata(t,regi,in,"price") *1.3;
    );
  );

  display "derivatives", p29_CESderivative, p29_effGr, p29_cesIO_load;

  !! Write prices to file and abort, to use them in calibration with differing
  !! CES structure
$ifthen.write_prices %c_CES_calibration_write_prices% == "1"
  file file_pm_cesdata_price /"pm_cesdata_price"/;

  file_pm_cesdata_price.lw =  0;
  file_pm_cesdata_price.nw = 20;
  file_pm_cesdata_price.nd = 15;

  put file_pm_cesdata_price;

  loop ((ttot,regi_dyn29(regi),ppf_29(in)),
    if (ttot.val ge 2005 AND p29_cesdata_load(ttot,regi,in,"price") gt 0,
      put p29_cesdata_load.tn(ttot,regi,in,"price"), " = ";
      put p29_cesdata_load(ttot,regi,in,"price"), ";" /;
    );
  );

  putclose file_pm_cesdata_price;

  abort "wrote pm_cesdata_price as by c_CES_calibration_write_prices setting" ;
$endif.write_prices
)

*** Abort if any ppf prices are <= 0
if (smin((t,regi_dyn29(regi),ppf_29(in)), pm_cesdata(t,regi,in,"price")) le 0,
  put logfile;
  loop ((t,regi_dyn29(regi),ppf_29(in))$( pm_cesdata(t,regi,in,"price") le 0 ),
    put pm_cesdata.tn(t,regi,in,"price"), " = ", pm_cesdata(t,regi,in,"price") /;
  );
  execute_unload "abort.gdx";
  abort "Some ppf prices are <= 0. Check ./modules/29_CES_parameters/calibrate/input/pm_cesdata_price_XXX.inc!";
);

*** Limit changes in prices for susceptible pf
if (sum((t,regi_dyn29(regi),in_limit_price_change_29(ppf_29(in))),
      (pm_cesdata(t,regi,in,"price") > 2   * p29_cesdata_load(t,regi,in,"price"))
    + (pm_cesdata(t,regi,in,"price") < 0.5 * p29_cesdata_load(t,regi,in,"price"))
    ),
  put logfile, " " / "limiting pf price changes" /;
  loop ((t,regi_dyn29(regi),in_limit_price_change_29(ppf_29(in))),
    sm_tmp 
    = pm_cesdata(t,regi,in,"price")
    / p29_cesdata_load(t,regi,in,"price");

    if (sm_tmp < 0.5 OR 2 < sm_tmp,
      put pm_cesdata.tn(t,regi,in,"price"), " [",
          p29_cesdata_load(t,regi,in,"price"), " -> ",
	  pm_cesdata(t,regi,in,"price"), "] -> ";

      pm_cesdata(t,regi,in,"price")
      = min(
          max(
            pm_cesdata(t,regi,in,"price"),
            0.5 * p29_cesdata_load(t,regi,in,"price")
          ),
          2 * p29_cesdata_load(t,regi,in,"price")
        );

      put pm_cesdata(t,regi,in,"price") /;
    );
  );
  putclose logfile, " " /;
);

*** Write prices to file
if (sm_CES_calibration_iteration eq 1, !! first CES calibration iteration
  put file_CES_calibration;

  loop ((t,regi_dyn29(regi),in)$(    ppf_29(in)
                                  OR sameas(in,"inco")
                                  OR ppf_beyondcalib_29(in)
                                  OR sameas(in,"enhb")
                                  OR sameas(in,"enhgab")       ),
    if ((ppf_29(in) OR sameas(in,"inco")),
      put "%c_expname%", "origin", t.tl, regi.tl, "quantity",   in.tl;
      put p29_cesIO_load(t,regi,in) /;

      put "%c_expname%", "origin", t.tl, regi.tl, "price",      in.tl;
      put pm_cesdata(t,regi,in,"price") /;

      if (p29_cesdata_load("2005",regi,in,"eff") AND p29_effGr(t,regi,in),
        put "%c_expname%", "origin", t.tl, regi.tl, "total efficiency", in.tl;
        put ( sum(cesOut2cesIn(out,in),
                p29_cesdata_load(t,regi,in,"xi")
             ** (1 / p29_cesdata_load(t,regi,out,"rho"))
              * ( p29_cesdata_load("2005",regi,in,"eff")
                * p29_effGr(t,regi,in)
                )
              )
            ) /;
      );
    );

    put "%c_expname%", "origin", t.tl, regi.tl, "efficiency", in.tl;
    put (p29_cesdata_load("2005",regi,in,"eff") * p29_effGr(t,regi,in)) /;

    put "%c_expname%", "origin", t.tl, regi.tl, "efficiency growth", in.tl;
    put p29_effGr(t,regi,in) /;

    put "%c_expname%", "origin", t.tl, regi.tl, "xi", in.tl;
    put p29_cesdata_load(t,regi,in,"xi") /;
  );

  loop ((ttot,regi_dyn29(regi),te_29_report),
    put "%c_expname%", "origin", ttot.tl, regi.tl, "vm_deltaCap";
    put te_29_report.tl;
    put sum(rlf,vm_deltaCap.L(ttot,regi,te_29_report,rlf)) /;
  );
  putclose file_CES_calibration;
);
option pm_cesdata:4:3:1;
display "loaded", pm_cesdata;


*** # Abort if any prices are zero or negative
sm_tmp = 0;
put logfile;
loop ((t_29(t),regi_dyn29(regi),ppf_29(in))$(
                                           pm_cesdata(t,regi,in,"price") le 0 ),
  put pm_cesdata.tn(t,regi,in,"price"), " = ", pm_cesdata(t,regi,in,"price") /;
  sm_tmp = 1;
);
putclose logfile;

if (sm_tmp eq 1,
  execute_unload "abort.gdx";
  abort "some prices are negative. See log file";
);

display "before price smoothing", cesOut2cesIn_below, pm_cesdata;
*** Smooth 2005 prices
pm_cesdata("2005",regi_dyn29(regi),in_29,"price")$( ppf_29(in_29) )
  = ( pm_cesdata("2010",regi,in_29,"price") * 2
    + pm_cesdata("2015",regi,in_29,"price")
    )
  / 3;

*** Smooth non 2005 prices with moving average
pm_cesdata(t,regi,in_29,"price")$(    (NOT (ord(t) le 1 OR ord(t) eq card(t)))
                                  AND ppf_29(in_29) )
  = ( pm_cesdata(t-1,regi,in_29,"price") / 8
    + pm_cesdata(t,  regi,in_29,"price")
    + pm_cesdata(t+1,regi,in_29,"price") / 8
    ) / 1.25;

*** Further smooth prices from 2005-2020 by calculating a linear fit
*** price_fit = alpha + beta * t
*** and then taking the arithmetic mean of the unsmoothed price and the linear fit

*** compute beta = cov(price,t) / var(t)
*** (search linear regression for more info)
p29_beta(regi_dyn29(regi),in_29)$( ppf_29(in_29) )
  = ( ((2020 - 2000) / 5)
    * sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ),
        ttot.val
      * pm_cesdata(ttot,regi,in_29,"price")
      )
    - ( sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ), ttot.val)
      * sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ),
          pm_cesdata(ttot,regi,in_29,"price")
        )
      )
    )
  / ( ((2020 - 2000) / 5)
    * sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ), sqr(ttot.val))
    - sqr(sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ), ttot.val))
    );

*** compute alpha = avg(price) - beta * avg(t)
p29_alpha(regi_dyn29(regi),in_29)$(ppf_29(in_29))
  = ( sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ),
        pm_cesdata(ttot,regi,in_29,"price")
      )
    - p29_beta(regi,in_29)
    * sum(ttot$( ttot.val ge 2005 AND ttot.val le 2020 ), ttot.val)
    )
  / ((2020 - 2000) / 5);

Display p29_alpha, p29_beta;


*** for entrp_frgt_lo (energy transport - freight transport - long distance)
*** pass on to pm_cesdata and ensure the resulting price is positive
$ifthen.edge_esm %transport% == "edge_esm"

loop (ttot$( ttot.val ge 2005 AND ttot.val lt 2020 ),
  pm_cesdata(ttot,regi_dyn29(regi),"entrp_frgt_lo","price")
  = max(
  1e-4,
    ( pm_cesdata(ttot,regi,"entrp_frgt_lo","price")
    + p29_alpha(regi,"entrp_frgt_lo")
    + p29_beta(regi,"entrp_frgt_lo") * ttot.val
    )
  / 2
  );
);

*** Set minimal price for all periods
loop (ttot$( ttot.val ge 2005),
  pm_cesdata(ttot,regi_dyn29(regi),"entrp_frgt_lo","price")
  = max(
    1e-4,
    pm_cesdata(ttot,regi,"entrp_frgt_lo","price")
    );
);

display "after entrp_frgt_lo smoothening", pm_cesdata;

$endif.edge_esm

*** for all other modes
*** pass on to pm_cesdata and ensure the resulting price is positive
loop (ttot$( ttot.val ge 2005 AND ttot.val lt 2020),
  pm_cesdata(ttot,regi_dyn29(regi),in_29,"price")$(ppf_29(in_29) AND (NOT sameas(in_29, "entrp_frgt_lo")))
  = max(
    1e-2,
    ( pm_cesdata(ttot,regi,in_29,"price")
      + p29_alpha(regi,in_29) + p29_beta(regi,in_29) * ttot.val
      )
    / 2
  );
);

*** Set minimal price for all periods
loop (ttot$( ttot.val ge 2005),
  pm_cesdata(ttot,regi_dyn29(regi),in_29,"price")$( ppf_29(in_29) AND (NOT sameas(in_29,"entrp_frgt_lo")) )
  = max(
    ( 1e-2$( NOT (in_buildings_dyn36(in_29) OR in_industry_dyn37(in_29)) )
    + 1e-4$(     (in_buildings_dyn36(in_29) OR in_industry_dyn37(in_29)) )
    ),
    pm_cesdata(ttot,regi,in_29,"price")
  );
);

display "after all but entrp_frgt_lo smoothening", pm_cesdata;

display "after price smoothing",  cesOut2cesIn_below;

***_____________________________ END OF:  1 - CALCULATE PRICES _____________________________

***_____________________________ START OF:  2 - CALCULATE QUANTITIES_____________________________

*** All effGr, are set to one, so that we can focus on efficiencies
*** we will split xi and eff evolutions later and pass it on to effGr
pm_cesdata(t,regi_dyn29,in_29,"effGr") = 1;

*** First, using the prices and quantities of the ppfEn, the prices of ipf
*** we compute thanks to the Euler equation the quantities of the ipf.
*** we compute quantities for everything up to the last CES level inco.(lab,kap,en)

!! Write to file
if (sm_CES_calibration_iteration eq 1, !! first CES calibration iteration
  put file_CES_calibration;

  loop ((t,regi_dyn29(regi),in)$(    ppf_29(in)
                                  OR sameas(in,"inco")
                                  OR ppf_beyondcalib_29(in)
                                  OR sameas(in,"enhb")
                                  OR sameas(in,"enhgab")       ),
    if ((ppf_29(in) OR sameas(in,"inco")),
      put "%c_expname%", "target", t.tl, regi.tl, "quantity",   in.tl;
      put pm_cesdata(t,regi,in,"quantity") /;
    );
  );

  loop ((t_29hist(t),regi_dyn29(regi),ppf_beyondcalib_29(in)),
    put "%c_expname%", "target", t.tl, regi.tl, "quantity", in.tl;
    put pm_cesdata(t,regi,in,"quantity") /;
  );

$ifthen.subsectors "%industry%" == "subsectors"
$ifthen.industry_FE_target "%c_CES_calibration_industry_FE_target%" == "1"
  loop((t_29scen(t),regi_dyn29(regi),in)$(   ppfen_industry_dyn37(in)
                                          OR ppfKap_industry_dyn37(in) ),
    put "%c_expname%", "target", t.tl, regi.tl, "quantity", in.tl;
    put pm_cesdata(t,regi,in,"quantity") /;
  );
$endif.industry_FE_target
$endif.subsectors

  putclose file_CES_calibration;
);

loop  ((t,cesRev2cesIO(counter,ipf_29(out)))$( NOT (  sameas(out,"inco")) ),
  pm_cesdata(t,regi_dyn29,out,"quantity")
  = sum(cesOut2cesIn(out,in),
      pm_cesdata(t,regi_dyn29,in,"price")
    * pm_cesdata(t,regi_dyn29,in,"quantity")
    );
);
*** Ensure that the labour share in GDP is at least 20 % for historical periods
*** and 0.5 % for others.
sm_tmp  = 0;
sm_tmp2 = 0;

put logfile;
loop ((t_29hist(t),regi_dyn29(regi)),
  sm_tmp
  = sum(in$(sameAs(in, "kap") OR sameAs(in,"en")),
      pm_cesdata(t,regi,in,"quantity")
    * pm_cesdata(t,regi,in,"price")
    )
    / pm_cesdata(t,regi,"inco","quantity");


   if ( (0.8$( t_29hist(t) ) + 0.995$( NOT t_29hist(t) )) lt sm_tmp,

   put t.tl, " ", regi.tl, " labour share in GDP: ", (1 - sm_tmp);

     pm_cesdata(t,regi,ppf_29(in),"price") $ ( NOT sameAs(in, "lab"))
     = pm_cesdata(t,regi,in,"price")
     * (0.8$( t_29hist(t) ) + 0.995$( NOT t_29hist(t) ))
     / sm_tmp;

     put " -> ", (1 - (0.8$( t_29hist(t) ) + 0.995$( NOT t_29hist(t) ))) /;
     sm_tmp2 = sm_tmp2 + 1;
     );
);
putclose logfile;
!! If there has been a rescaling for historical steps, repeat previous steps with new prices
if ( sm_tmp2 gt 0, !! If there has been a rescaling

  loop  ((t,cesRev2cesIO(counter,ipf_29(out)))$( NOT ( sameas(out,"inco"))),

    pm_cesdata(t,regi_dyn29,out,"quantity")
    = sum(cesOut2cesIn(out,in),
        pm_cesdata(t,regi_dyn29,in,"price")
      * pm_cesdata(t,regi_dyn29,in,"quantity")
      );
  );   
);

***_____________________________ END OF:  2 - CALCULATE QUANTITIES_____________________________

***_____________________________ START OF: 3 - CALCULATE EFFICIENCIES _____________________________

*** We ensure that the prices correspond to the derivatives, because
*** the Euler equation holds for derivatives. Using prices makes only sense if
*** prices equal derivatives.
loop  ((cesRev2cesIO(counter,ipf_29(out)),ces_29(out,in))$(
                                                    NOT sameas(out,"inco") ),
    pm_cesdata(t,regi_dyn29, in,"xi")
      = pm_cesdata(t,regi_dyn29,in,"price")
      * pm_cesdata(t,regi_dyn29,in,"quantity")
      / pm_cesdata(t,regi_dyn29,out,"quantity");

   pm_cesdata(t,regi_dyn29,in,"eff")
      = pm_cesdata(t,regi_dyn29,out, "quantity")
      / pm_cesdata(t,regi_dyn29,in, "quantity");
);
display "after change up to en consistency", pm_cesdata;

***_____________________________ END OF: 3 - CALCULATE EFFICIENCIES _____________________________

***_____________________________ START OF: 4 - ADJUST LABOUR PRICE to GDP _____________________________

*** Then, we consider the top level of the CES tree, where capital and labor
*** have specific restrictions. Capital works as for the other ppfen, Labour
*** will be the adjustment variable to meet inco. xi will not be equal to the
*** income share of capital (from equation price = derivative)

pm_cesdata(t,regi_dyn29,"kap","xi")
  = pm_cesdata(t,regi_dyn29,"kap","price")
  * pm_cesdata(t,regi_dyn29,"kap","quantity")
  / pm_cesdata(t,regi_dyn29,"inco","quantity");

pm_cesdata(t,regi_dyn29,"kap","eff")
  = pm_cesdata(t,regi_dyn29,"inco", "quantity")
  / pm_cesdata(t,regi_dyn29,"kap", "quantity");

display "after change cap eff consistency", pm_cesdata;

*** If the value (quantity x price) of either en or kap, or the sum of both,
*** exceed the quantity of inco (all of which would result in negative labour
*** prices), scale these prices down accordingly, and warn this is happening.
if (smax((t,regi_dyn29(regi)),
       sum(cesOut2cesIn("inco",in)$( NOT sameas(in,"lab") ),
         pm_cesdata(t,regi,in,"quantity")
       * pm_cesdata(t,regi,in,"price")
       )
     / pm_cesdata(t,regi,"inco","quantity")
     ) gt 1,   !! does the sum of en and cap exceed inco?
  put logfile, ">>> Warning: Rescaling en and kap prices as their combined ",
               "value exceeds inco <<<" /;
  loop ((t,regi_dyn29(regi)),
    sm_tmp   !! by how much does en + kap exceed inco?
    = ( (  pm_cesdata(t,regi,"en","quantity")
         * pm_cesdata(t,regi,"en","price")
        )
      + (  pm_cesdata(t,regi,"kap","quantity")
         * pm_cesdata(t,regi,"kap","price")
        )
      )
     / pm_cesdata(t,regi,"inco","quantity");

    if (sm_tmp > 1,
      put "  ", t.tl, " ", regi.tl, "   ",
          pm_cesdata(t,regi,"en","quantity"), " x ",
          pm_cesdata(t,regi,"en","price"), " + ",
          pm_cesdata(t,regi,"kap","quantity"), " x ",
          pm_cesdata(t,regi,"kap","price"), " > ",
          pm_cesdata(t,regi,"inco","quantity"), " -> ";

      sm_tmp2
      = ( pm_cesdata(t,regi,"inco","quantity")
        - ( pm_cesdata(t,regi,"lab","quantity")
          * pm_cesdata(t,regi,"lab","price")
          )
        )
      / ( ( pm_cesdata(t,regi,"en","quantity")
          * pm_cesdata(t,regi,"en","price")
          )
        + ( pm_cesdata(t,regi,"kap","quantity")
          * pm_cesdata(t,regi,"kap","price")
          )
        );

      pm_cesdata(t,regi,"en","price")
      = pm_cesdata(t,regi,"en","price")
      * sm_tmp2;

      pm_cesdata(t,regi,"kap","price")
      = pm_cesdata(t,regi,"kap","price")
      * sm_tmp2;

      put pm_cesdata(t,regi,"en","price"), ", ",
          pm_cesdata(t,regi,"kap","price") /;
    );
  );
  putclose logfile, " " /;
);

!! do either en or kap exceed inco?
loop (cesOut2cesIn("inco",in)$( NOT sameas(in,"lab") ),
  if (smax((t,regi_dyn29(regi)),
        pm_cesdata(t,regi,in,"quantity")
      * pm_cesdata(t,regi,in,"price")
      / pm_cesdata(t,regi,"inco","quantity")
      ) gt 1,
    put logfile, ">>> Warning: Rescaling ", in.tl, " prices as its value ",
                 "exceedes inco <<<" /;
    loop ((t,regi_dyn29(regi)),
           sm_tmp
           = pm_cesdata(t,regi,in,"quantity")
           * pm_cesdata(t,regi,in,"price")
           / pm_cesdata(t,regi,"inco","quantity");

          if (sm_tmp gt 1,
              put "  ", t.tl, " ", regi.tl, in.tl:>4, "   ",
               pm_cesdata(t,regi,in,"quantity"), " x ",
               pm_cesdata(t,regi,in,"price"), " > ",
               pm_cesdata(t,regi,"inco","quantity"), " -> ";

               pm_cesdata(t,regi,in,"price")
            = ( pm_cesdata(t,regi,"inco","quantity")
              - sum(cesOut2cesIn2("inco",in2)$( NOT sameas(in,in2) ),
                  pm_cesdata(t,regi,in2,"quantity")
                * pm_cesdata(t,regi,in2,"price")
                )
              )
             / pm_cesdata(t,regi,in,"quantity");

            put pm_cesdata(t,regi,in,"price") /;
         );
    );
    putclose logfile, " " /;
  );
);

*** Second, adjust the price of labour, so that, whithout changing the price of
*** energy, the Euler equation holds.
pm_cesdata(t,regi_dyn29,"lab","price")
  = ( pm_cesdata(t,regi_dyn29,"inco","quantity")
    - sum(cesOut2cesIn("inco",in)$( NOT sameas(in,"lab") ),
        pm_cesdata(t,regi_dyn29,in,"price")
      * pm_cesdata(t,regi_dyn29,in,"quantity")
      )
    )
  / pm_cesdata(t,regi_dyn29,"lab","quantity")
;

*** Fourth, adjust eff and xi of labour, energy, and capital, so that the price
*** matches the derivative.
loop ((t,regi_dyn29,ces_29("inco",in)),
  pm_cesdata(t,regi_dyn29,in,"xi")
  = pm_cesdata(t,regi_dyn29,in,"price")
  * pm_cesdata(t,regi_dyn29,in,"quantity")
  / pm_cesdata(t,regi_dyn29,"inco","quantity");

  pm_cesdata(t,regi_dyn29,in,"eff")
  = pm_cesdata(t,regi_dyn29,"inco","quantity")
  / pm_cesdata(t,regi_dyn29,in,"quantity");
);

*** Assert xi gt 0
sm_tmp = 0;
loop ((t,regi_dyn29(regi),in_29)$(
                                     pm_cesdata(t,regi,in_29,"xi")       le 0
                                 AND pm_cesdata(t,regi,in_29,"quantity") gt 0
                                 AND NOT sameas(in_29,"inco")                 ),
  sm_tmp = 1;
);

if (sm_tmp,
  put logfile;
  loop ((t,regi_dyn29(regi),in_29)$(
                                     pm_cesdata(t,regi,in_29,"xi")       le 0
                                 AND pm_cesdata(t,regi,in_29,"quantity") gt 0
                                 AND NOT sameas(in_29,"inco")                 ),
    put pm_cesdata.tn(t,regi,in_29,"xi"), " = ";
    put pm_cesdata(t,regi,in_29,"xi") /;

    loop (cesOut2cesIn(out,in_29),
      put @3, pm_cesdata.tn(t,regi,out,"quantity"), " = ",
          pm_cesdata(t,regi,out,"quantity") /;

      loop (cesOut2cesIn2(out,in),
        put @5, pm_cesdata.tn(t,regi,in,"price"), " = ",
            pm_cesdata(t,regi,in,"price") /;
        put @5, pm_cesdata.tn(t,regi,in,"quantity"), " = ",
            pm_cesdata(t,regi,in,"quantity") /;
      );
    );
  );

  execute_unload "abort.gdx";
  abort "assertion xi gt 0 failed, see .log file for details";
);

display " end consistency", pm_cesdata;
*** End of the part ensuring consistency given the ppfEn prices and quantities, the ipf prices,
*** the labor quantities, and the capital efficiency growth.

***_____________________________ END OF: 4 - ADJUST LABOUR PRICE to GDP _____________________________

***_____________________________ START OF: BEYOND CALIBRATION PART I _________________________________________________

*** Beyond calib allows for calibration of intermediate levels.
*** At the time of documentation, this was mainly used for the industry module subsectors realization.
*** Here, the above steps are only carried out down to the UE level of the different sectors.
*** (Hence sets like 'in' have a trimmed duplicate like 'in_29').
*** 'Beyond calib' now handles the part of the CES tree below this intermediate level.
*** To this end, in the following, a similar procedure as for the upper part of the tree is carried out.
*** However, consistency with the top most node(s) of the respective part of the tree is handled differently:
*** Here, all ppfen prices are scaled in beyond calib, instead of labour price in the 'normal' part.

if (card(ppf_beyondcalib_29) >= 1, !! if there are any nodes in beyond calib
  Display "  before computing xi in beyond", pm_cesdata;

  !! if prices haven't already been loaded
  if (sm_CES_calibration_iteration > 1 or s29_CES_calibration_new_structure eq 0,

    !! Compute ppf prices from CES derivatives of previous run
    p29_CESderivative(t,regi_dyn29(regi),cesOut2cesIn(out,in))$(
                                                      p29_cesIO_load(t,regi,in) )
      = p29_cesdata_load(t,regi,in,"xi")
      * p29_cesdata_load(t,regi,in,"eff")
      * p29_effGr(t,regi,in)
      * p29_cesIO_load(t,regi,out)

      ** (1 - p29_cesdata_load(t,regi,out,"rho"))

      * exp(
           log(
                p29_cesdata_load(t,regi,in,"eff")
              * p29_effGr(t,regi,in)
              * p29_cesIO_load(t,regi,in)
           )
        * (p29_cesdata_load(t,regi,out,"rho") - 1)
        );

    !! Propagate price down the CES tree
    loop ((cesLevel2cesIO(counter,in),cesOut2cesIn(in,in2),cesOut2cesIn2(in2,in3)),
      p29_CESderivative(t,regi_dyn29(regi),"inco",in3)
      = p29_CESderivative(t,regi,"inco",in2)
      * p29_CESderivative(t,regi,in2,in3);
    );


    !! Prices of intermediate production factors are all 1
    loop (cesOut2cesIn(in2,in),
      p29_CESderivative(t,regi_dyn29(regi),out,ipf_beyond_29_excludeRoot(in2))$(
                                              p29_CESderivative(t,regi,out,in2) )
      = 1;
    );

    display "check p29_CESderivative", p29_CESderivative;

    loop ((regi_dyn29(regi),
          cesOut2cesIn(out,in_beyond_calib_29_excludeRoot(in))),
      pm_cesdata(t,regi,in,"price")
      = p29_CESderivative(t,regi,out,in);
    );

$ifthen.subsectors "%industry%" == "subsectors"
$ifthen.FE_target "%c_CES_calibration_industry_FE_target%" == "1" !! c_CES_calibration_industry_FE_target
    !! set minimum price on ppf_industry
    pm_cesdata(t,regi_dyn29(regi),ppf_industry_dyn37(in),"price")$(NOT ue_industry_dyn37(in))
    = max(pm_cesdata(t,regi,in,"price"), 1e-5);
$endif.FE_target
$endif.subsectors

    !! smooth historical prices
    pm_cesdata(t_29hist(t),regi_dyn29(regi),in,"price")$(
                                              in_beyond_calib_29_excludeRoot(in) )
    = (0.25 * pm_cesdata(t,regi,in,"price"))
    + ( 0.75
      * sum(t_29hist2(t2), pm_cesdata(t2,regi,in,"price"))
      / card(t_29hist2)
      );

  else
    pm_cesdata(t,regi,ipf_beyond_29(in),"price")$( NOT ue_industry_dyn37(in) )
    = 1;
  );

  !! The calibration of elasticities of substitution takes much longer to
  !! converge if it starts from a high elasticity of substitution. To avoid
  !! this situation, the price of the capital stock is increased.
  if (sm_CES_calibration_iteration eq 1,
    loop (cesOut2cesIn(out,in_beyond_calib_29_excludeRoot(ppfKap(in)))$(
                                            pm_cesdata_sigma("2015",out) eq -1 ),
      pm_cesdata(t,regi,in,"price")
      = pm_cesdata(t,regi,in,"price")
      * 5;
    );
  );

  !! Report prices based on the inco marginal, before they are scaled.
  put capital_unit;

  loop ((t,regi_dyn29(regi),cesOut2cesIn(out,in),cesOut2cesIn2(out,in2))$(
                            ppfKap(in) AND (NOT ppfKap(in2))
                        AND (t.val eq 2005 OR t.val eq 2050 OR t.val eq 2100)
                        AND pm_cesdata_sigma(t,out) eq -1                     ),

    if (sm_CES_calibration_iteration eq 1 and s29_CES_calibration_new_structure eq 1,
      put sm_CES_calibration_iteration:0:0, "remind", t.tl, in.tl ;
      put "price_Noscale", regi.tl, pm_cesdata(t,regi,in,"price") /;
      put sm_CES_calibration_iteration:0:0, "remind", t.tl, in2.tl;
      put "price_Noscale", regi.tl, pm_cesdata(t,regi,in2,"price") /;
    else
      put sm_CES_calibration_iteration:0:0, "remind", t.tl, in.tl;
      put "price_Noscale", regi.tl, p29_CESderivative(t,regi,"inco",in) /;
      put sm_CES_calibration_iteration:0:0, "remind", t.tl, in2.tl;
      put "price_Noscale", regi.tl, p29_CESderivative(t,regi,"inco",in2) /;
    );
  );
  putclose;

  !! First, we compute the quantity for the root deriving from the ppf
  !! quantities and prices and we adjust the ppf prices so that it matches the
  !! root quantity. 

  loop ((t_29hist(t),regi_dyn29(regi),root_beyond_calib_29(out)),
    sm_tmp
    = sum(cesOut2cesIn_below(out,ppf(in)),
        pm_cesdata(t,regi,in,"price")
      * pm_cesdata(t,regi,in,"quantity")
      )
    / pm_cesdata(t,regi,out,"quantity");

    if (sm_tmp le 0,
      put logfile;
      put "sm_tmp   [", t.tl, ",", regi.tl, ",", out.tl, "]" /;
      put " = sum(cesOut2cesIn('", out.tl, "',in)," /;
      loop (cesOut2cesIn_below(out,in),
        put "      ", in.tl, @30 pm_cesdata(t,regi,in,"quantity");
        put " @ ", pm_cesdata(t,regi,in,"price") /;
      );
      put "   ) " /;
      put " / ", pm_cesdata(t,regi,out,"quantity") /;
      put " = ", sm_tmp /;
      put " " /;

      loop (cesOut2cesIn(out,in),
        put pm_cesdata.tn(t,regi,in,"quantity"), " = ";
        put pm_cesdata(t,regi,in,"quantity") /;
        put pm_cesdata.tn(t,regi,in,"price"), " = ";
        put pm_cesdata(t,regi,in,"price") /;
      );

      execute_unload "abort.gdx";
      abort "assertion sm_tmp is <= 0, see .log file for details";
    );

    loop (cesOut2cesIn_below(out,ppf(in)),
     !! adjust the price for historical periods
      pm_cesdata(t,regi,in,"price") $ (
                                t_29hist(t))
      = pm_cesdata(t,regi,in,"price")
      / sm_tmp;
     !! adjust the quantity for scenario periods
      pm_cesdata(t,regi,in,"quantity") $ (
                                t_29scen(t))
      = pm_cesdata(t,regi,in,"quantity")
      / sm_tmp;
    );
  );

  loop ((t_29,cesRev2cesIO(counter,ipf_beyond_29_excludeRoot(out)))$(
                                                   NOT sameas(out,"inco") ),
    pm_cesdata(t_29,regi_dyn29,out,"quantity")
    = sum(cesOut2cesIn(out,in),
        pm_cesdata(t_29,regi_dyn29,in,"price")
      * pm_cesdata(t_29,regi_dyn29,in,"quantity")
      );
  );

  loop ((t_29hist(t_29),cesOut2cesIn(out,in_beyond_calib_29_excludeRoot(in))),
      pm_cesdata(t_29,regi_dyn29,in,"xi")
      = pm_cesdata(t_29,regi_dyn29,in,"price")
      * pm_cesdata(t_29,regi_dyn29,in,"quantity")
      / pm_cesdata(t_29,regi_dyn29,out,"quantity");

      pm_cesdata(t_29,regi_dyn29,in,"eff")
      = pm_cesdata(t_29,regi_dyn29,out,"quantity")
      / pm_cesdata(t_29,regi_dyn29,in,"quantity");
  );
);

***_____________________________ END OF: BEYOND CALIBRATION PART I ________________________________________

***_____________________________ START OF: 5 - COMPUTE ELASTICITIES OF SUBSTITUTION ________________________________________


*** Compute the rho parameter from the elasticity of substitution
pm_cesdata(ttot,regi,ipf(out),"rho")$(    ttot.val ge 2005
                                      AND pm_cesdata_sigma(ttot,out)
                                      AND pm_cesdata_sigma(ttot,out) ne -1 )
    !! Do not compute it if sigma = 0, because these should be estimated
  = 1 - (1 / pm_cesdata_sigma(ttot,out));
***_____________________________ END OF: COMPUTE ELASTICITIES OF SUBSTITUTION ________________________________________

***_____________________________ START OF: 5 - PASS EFF TIME EVOLUTION TO EFFGR ________________________________________

*** Finally, we take the evolution of xi and eff, and pass it on to effGr.
*** (a) for items in ces_29
loop ((t,regi_dyn29(regi),ces_29(out,in),t0),
  pm_cesdata(t,regi,in,"effgr")$( pm_cesdata(t,regi,in,"quantity") gt 0 )
  = (pm_cesdata(t,regi,in,"eff") / pm_cesdata(t0,regi,in,"eff"))
  * (pm_cesdata(t,regi,in,"xi")  / pm_cesdata(t0,regi,in,"xi"))
 ** (1 / pm_cesdata(t,regi,out,"rho"));

  pm_cesdata(t,regi,in,"eff") = pm_cesdata(t0,regi,in,"eff");
  pm_cesdata(t,regi,in,"xi")  = pm_cesdata(t0,regi,in,"xi");
);

pm_cesdata(t,regi_dyn29(regi),"inco","effgr") = 1;

*** (b) for items beyond calibration, whose growth beyond t_29hist is treated
*** below

loop ((t_29,t0,cesOut2cesIn(out,in),regi_dyn29(regi))$(
                                     ces_beyondcalib_29(out,in)
                                 AND t_29hist(t_29) ),
  pm_cesdata(t_29,regi,in,"effgr")$( pm_cesdata(t_29,regi,in,"quantity") gt 0 )
  = (pm_cesdata(t_29,regi,in,"eff") / pm_cesdata(t0,regi,in,"eff"))
  * (pm_cesdata(t_29,regi,in,"xi")  / pm_cesdata(t0,regi,in,"xi"))
 ** (1 / pm_cesdata(t_29,regi,out,"rho"));

  pm_cesdata(t_29,regi,in,"eff") = pm_cesdata(t0,regi,in,"eff");
  pm_cesdata(t_29,regi,in,"xi")  = pm_cesdata(t0,regi,in,"xi");
);

loop ((t0,in_beyond_calib_29_excludeRoot),
  pm_cesdata(t_29,regi_dyn29,in,"eff") = pm_cesdata(t0,regi_dyn29,in,"eff");
  pm_cesdata(t_29,regi_dyn29,in,"xi")  = pm_cesdata(t0,regi_dyn29,in,"xi");
);


*** For beyond calib: treatment of effGr after historical periods

*** First, initialize effGr to the last value of the historical period
loop ((t_29hist_last(t2),regi_dyn29(regi),cesOut2cesIn(out,in))$(
                                           in_beyond_calib_29_excludeRoot(in)
                                       AND NOT ue_fe_kap_29(out)),
  pm_cesdata(t_29,regi,in, "effGr")$( pm_ttot_val(t_29) gt pm_ttot_val(t2) )
  = pm_cesdata(t2,regi,in, "effGr");
);

***_____________________________ END OF: 5 - PASS EFF TIME EVOLUTION TO EFFGR ________________________________________


***_____________________________ START OF: BEYOND CALIBRATION PART II ________________________________________

$ifthen.subsectors "%industry%" == "subsectors"
$ifthen.industry_FE_target "%c_CES_calibration_industry_FE_target%" == "1"

*** c_CES_calibration_industry_FE_target == 1 means that
*** industry ppfen input prices are scaled to make the Euler identity hold

*** Limit changes in prices for industry EEK
if (sum((t,regi_dyn29(regi),in_limit_price_change_29(ppfKap_industry_dyn37(in))),
      (pm_cesdata(t,regi,in,"price") > 2   * p29_cesdata_load(t,regi,in,"price"))
    + (pm_cesdata(t,regi,in,"price") < 0.5 * p29_cesdata_load(t,regi,in,"price"))
    ),
  put logfile, " " / "limiting pf price changes" /;
  loop ((t,regi_dyn29(regi),in_limit_price_change_29(ppfKap_industry_dyn37(in))),
    sm_tmp 
    = pm_cesdata(t,regi,in,"price")
    / p29_cesdata_load(t,regi,in,"price");

    if (sm_tmp < 0.5 OR 2 < sm_tmp,
      put pm_cesdata.tn(t,regi,in,"price"), " [",
          p29_cesdata_load(t,regi,in,"price"), " -> ",
	  pm_cesdata(t,regi,in,"price"), "] -> ";

      pm_cesdata(t,regi,in,"price")
      = min(
          max(
            pm_cesdata(t,regi,in,"price"),
            0.5 * p29_cesdata_load(t,regi,in,"price")
          ),
          2 * p29_cesdata_load(t,regi,in,"price")
        );

      put pm_cesdata(t,regi,in,"price") /;
    );
  );
  putclose logfile, " " /;
);

*** Abort if any industry EEK value is higher than subsector output quantity
sm_tmp = smin((t,regi_dyn29(regi),
               cesOut2cesIn(ue_industry_dyn37(out),ppfKap(in))
               ),
             pm_cesdata(t,regi,out,"quantity")
          - ( pm_cesdata(t,regi,in,"quantity")
            * pm_cesdata(t,regi,in,"price")
            )
         );
if (0 gt sm_tmp,
  put logfile,  "Error in industry FE price rescaling: ",
                "EEK value exceeds subsector output quantity" /;
  logfile.nr = 1;
  loop ((t,regi_dyn29(regi),
         cesOut2cesIn(ue_industry_dyn37(out),ppfKap(in))),
    sm_tmp = pm_cesdata(t,regi,out,"quantity")
           - ( pm_cesdata(t,regi,in,"quantity")
             * pm_cesdata(t,regi,in,"price")
             );
    if (0 gt sm_tmp,
      put t.tl, ".", regi.tl, "   ", out.tl:>20,
          pm_cesdata(t,regi,out,"quantity"):>10:4, " < ",
          pm_cesdata(t,regi,in,"quantity"):>8:4, " x ",
          pm_cesdata(t,regi,in,"price"):<8:4, " ",
          in.tl:<0 /;
    );
  );
  putclose logfile, " " /;
  execute_unload "abort.gdx";
  abort "assertion EEK value < subsector output quantity failed. See log for details.";
);

*** scale industry ppfen input prices as a slack variable to make the Euler identity
*** hold
put logfile, ">>> Industry FE Price Rescaling <<<" /;
loop ((t,regi_dyn29(regi),ue_industry_dyn37(out)),
  if (not sum(in,ue_industry_2_pf(out,in)),
    sm_tmp = 1;
  else
    sm_tmp
    = ( pm_cesdata(t,regi,out,"quantity")
      - sum(cesOut2cesIn(out,ppfKap(in)),
          pm_cesdata(t,regi,in,"quantity")
        * pm_cesdata(t,regi,in,"price")
        )
      )
    / sum(ue_industry_2_pf(out,ppfen_industry_dyn37(in)),
        pm_cesdata(t,regi,in,"price")
      * pm_cesdata(t,regi,in,"quantity")
      );
  );

  if (sm_tmp ne 1,
    loop (ue_industry_2_pf(out,ppfen_industry_dyn37(in)),
      put pm_cesdata.tn(t,regi,in,"price"),
          @60 pm_cesdata(t,regi,in,"price"), " x ";
      if (abs(sm_tmp - 1) lt 1e-2,
        if (sm_tmp gt 1,
          put "(1 + ", (sm_tmp - 1), ") = ";
        else
          put "(1 - ", (1 - sm_tmp), ") = ";
        );
      else
        put "     ", sm_tmp, "  = ";
      );

      pm_cesdata(t,regi,in,"price")
      = pm_cesdata(t,regi,in,"price")
      * sm_tmp;

      put pm_cesdata(t,regi,in,"price") /;
    );
  );
);
putclose logfile, " " /;

*** recompute all ipf from Euler equation
loop (cesRev2cesIO(counter,ipf_industry_dyn37(out))$(
                                                   NOT ue_industry_dyn37(out) ),
  pm_cesdata(t,regi_dyn29(regi),out,"quantity")
  = sum(cesOut2cesIn(out,in),
      pm_cesdata(t,regi,in,"price")
    * pm_cesdata(t,regi,in,"quantity")
    );
);

loop ((t,regi_dyn29(regi),cesOut2cesIn(out,in_industry_dyn37(in)))$(
                                                    NOT ue_industry_dyn37(in) ),
  pm_cesdata(t,regi,in,"xi")
  = pm_cesdata(t,regi,in,"price")
  * pm_cesdata(t,regi,in,"quantity")
  / pm_cesdata(t,regi,out,"quantity");

  pm_cesdata(t,regi,in,"eff")
  = pm_cesdata(t,regi,out,"quantity")
  / pm_cesdata(t,regi,in,"quantity");

  loop (t0,
    pm_cesdata(t,regi,in,"effGr")$( pm_cesdata(t,regi,in,"quantity") gt 0 )
    = (pm_cesdata(t,regi,in,"eff") / pm_cesdata(t0,regi,in,"eff"))
    * (pm_cesdata(t,regi,in,"xi")  / pm_cesdata(t0,regi,in,"xi"))
   ** (1 / pm_cesdata(t,regi,out,"rho"));

    pm_cesdata(t,regi,in,"eff") = pm_cesdata(t0,regi,in,"eff");
    pm_cesdata(t,regi,in,"xi")  = pm_cesdata(t0,regi,in,"xi");
  );
);
$else.industry_FE_target

*** c_CES_calibration_industry_FE_target == 0 means that
*** the efficiency time evolution computed above if discarded and instead
*** efficiency improvements assumptions to industrial final energy and capital inputs are applied:
loop ((t_29hist_last(t2),cesOut2cesIn_below(out,in))$(
                                            industry_ue_calibration_target_dyn37(out)
                                            AND ppf_beyondcalib_29(in)),
  pm_cesdata(t_29,regi_dyn29(regi),in, "effGr")$( NOT t_29hist(t_29) )
  = pm_cesdata(t2,regi,in, "effGr")
  * ((1 + pm_ue_eff_target(out)) ** (t_29.val - pm_ttot_val(t2)))
  ;
);
$endif.industry_FE_target

!! - adjust efficiency parameters for feelhth_X and feh2_X
$ifthen.industry_FE_target "%c_CES_calibration_industry_FE_target%" == "0"
loop (cesOut2cesIn(in_industry_dyn37(out),in)$(
                              (ppfEn(in) OR ipf(in))
                          AND NOT industry_ue_calibration_target_dyn37(out)
                          AND NOT cesOut2cesIn_below("ue_steel_secondary",in) ),
  !! in2 is the reference energy input (gas if 'in' is H2)
  loop (in2$( pm_calibrate_eff_scale(in,in2,"level") ),
    !! compute the parameter describing the speed of convergence towards in2
    p29_t_tmp(t)$( t_29scen(t) )
    = pm_calibrate_eff_scale(in,in2,"level")
    / ( 1
      + exp((pm_calibrate_eff_scale(in,in2,"midperiod") - t.val)
          / pm_calibrate_eff_scale(in,in2,"width")
          )
      );

    p29_t_tmp(t) = p29_t_tmp(t) - sum(t0, p29_t_tmp(t0));
    p29_t_tmp(t) = min(1, max(0, p29_t_tmp(t)));

    pm_cesdata(t_29scen(t),regi_dyn29(regi),in,"effGr")
    =  1
       / ( pm_cesdata(t,regi,in,"eff")
          * pm_cesdata(t,regi,in,"xi")
          ** (1
              / pm_cesdata(t,regi,out,"rho")
              )
          )
       * (
          (1 - p29_t_tmp(t))
           * ( pm_cesdata(t,regi,in,"xi")
               ** ( 1
                     / pm_cesdata(t,regi,out,"rho")
                   )
             * pm_cesdata(t,regi,in,"eff")
             * pm_cesdata(t,regi,in,"effGr")
             )
          + p29_t_tmp(t)
           * ( pm_cesdata(t,regi,in2,"xi")
               ** ( 1
                     / pm_cesdata(t,regi,out,"rho")
                   )
             * pm_cesdata(t,regi,in2,"eff")
             * pm_cesdata(t,regi,in2,"effGr")
             )
         );
   );
);
$endif.industry_FE_target
$endif.subsectors

***_____________________________ END OF: BEYOND CALIBRATION PART II ________________________________________

display "after long term efficiencies", pm_cesdata;

*** All efficiences after t_29_last are set to their t_29_last values. This is
*** done in order to avoid xi negative in the latest periods. Should not be
*** necessary to split pre and post-t_29_last with reasonable FE pathways
* Exclude industry from this, since it may lead to infeasibilities.
loop ((t,t_29_last,in)$(    t.val gt t_29_last.val
                        AND NOT in_industry_dyn37(in) ),
  pm_cesdata(t,regi_dyn29(regi),in,"effGr")
  = pm_cesdata(t_29_last,regi,in,"effGr");

  pm_cesdata(t,regi_dyn29(regi),in,"eff")
  = pm_cesdata(t_29_last,regi,in,"eff");

  pm_cesdata(t,regi_dyn29(regi),in,"xi")
  = pm_cesdata(t_29_last,regi,in,"xi");

);

*** REPORTING for the elasticities of substitution
*** it has been separated from the esubs model results since the PDF reporting needs the CES efficiencies after 2015 as well
put capital_unit;
loop (regi_dyn29(regi),
loop ((out,in,in2,t)$((pm_cesdata_sigma(t,out) eq -1)
                                    AND ( cesOut2cesIn(out,in) AND cesOut2cesIn2(out,in2))
                                    AND ( ppfKap(in) AND ( NOT ppfKap(in2)))
                                    AND (sameAs(t, "2015") OR sameAs(t, "2050") OR sameAs(t, "2100"))) ,

       put sm_CES_calibration_iteration:0:0, "remind" , t.tl, out.tl   , "quantity", regi.tl, pm_cesdata(t,regi,out,"quantity") /;
       put sm_CES_calibration_iteration:0:0, "remind" , t.tl, in.tl , "quantity", regi.tl, pm_cesdata(t,regi,in,"quantity") /;
       put sm_CES_calibration_iteration:0:0, "remind" , t.tl, in2.tl  , "quantity", regi.tl, pm_cesdata(t,regi,in2,"quantity") /;

       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in.tl , "eff", regi.tl, pm_cesdata(t,regi,in,"eff") /;
       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in2.tl  , "eff", regi.tl, pm_cesdata(t,regi,in2,"eff") /;

       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in.tl , "effGr", regi.tl, pm_cesdata(t,regi,in,"effGr") /;
       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in2.tl  , "effGr", regi.tl, pm_cesdata(t,regi,in2,"effGr") /;

       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in.tl , "xi", regi.tl, pm_cesdata(t,regi,in,"xi") /;
       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in2.tl  , "xi", regi.tl, pm_cesdata(t,regi,in2,"xi") /;

       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in.tl , "price", regi.tl, pm_cesdata(t,regi,in,"price") /;
       put sm_CES_calibration_iteration:0:0,"remind" , t.tl, in2.tl  , "price", regi.tl, pm_cesdata(t,regi,in2,"price") /;

       put sm_CES_calibration_iteration:0:0,"remind" , t.tl,out.tl  , "rho", regi.tl, pm_cesdata(t,regi,out,"rho") /;
       );
);
putclose;


***_____________________________ START OF: CONSISTENCY CHECKS ________________________________________

*** check technological consistency of the CES tree.
p29_test_CES_recursive(t_29,regi,in) = 0;

p29_test_CES_recursive(t_29hist,regi_dyn29,ppf(in))
= pm_cesdata(t_29hist,regi_dyn29,in,"quantity");

p29_test_CES_recursive(t_29,regi_dyn29,ppf_29(in))
= pm_cesdata(t_29,regi_dyn29,in,"quantity");

display "consistency beyond 1", p29_test_CES_recursive;

*** test for the historical periods, where beyond_calib is also taken into account
loop ((t_29hist(t),regi_dyn29(regi),cesRev2cesIO(counter,ipf(out))),

  p29_test_CES_recursive(t,regi,out)
  = sum(cesOut2cesIn(out,in),
      pm_cesdata(t,regi,in,"xi")
    * ( pm_cesdata(t,regi,in,"eff")
      * pm_cesdata(t,regi,in,"effGr")
      * p29_test_CES_recursive(t,regi,in)
      )
   ** pm_cesdata(t,regi,out,"rho")
    )
 ** (1 / pm_cesdata(t,regi,out,"rho"));

);
putclose logfile;

display "consistency beyond 2", p29_test_CES_recursive;

*** test for the other periods, and restrict to in_29
loop ((t_29(t),regi_dyn29(regi),cesRev2cesIO(counter,ipf_29(out)))$(
                                                              NOT t_29hist(t) ),

  p29_test_CES_recursive(t,regi,out)
  !! use exp(log(a) * b) = a ** b because the latter is not accurate in GAMS
  = exp(
      log(
        sum(cesOut2cesIn(out,in),
          pm_cesdata(t,regi,in,"xi")
        * exp(
            log(
              ( pm_cesdata(t,regi,in,"eff")
              * pm_cesdata(t,regi,in,"effGr")
              * p29_test_CES_recursive(t,regi,in)
              )
            )
          * pm_cesdata(t,regi,out,"rho")
          )
        )
      )
    * (1 / pm_cesdata(t,regi,out,"rho"))
    );
);

display "consistency beyond 3", p29_test_CES_recursive;

option p29_test_CES_recursive:8;
display "check technological consistency beyond calibration", pm_cesdata,
        p29_test_CES_recursive;

sm_tmp = 0;
loop ((t_29(t),regi_dyn29(regi),cesOut2cesIn(out,in))$( NOT sameas(in,"inco") ),
  if (   pm_cesdata(t,regi,in,"effGr") lt 1e-10
     AND ( pm_cesdata(t,regi,in,"xi")
         * ( pm_cesdata(t,regi,in,"eff")
           * pm_cesdata(t,regi,in,"effGr")
           )
        ** pm_cesdata(t,regi,out,"rho")
         ) lt 1e-10,

    put logfile;
    if (sm_tmp eq 0,
      put ">>> Too low efficiency growth and total efficiency parameters <<<" /;
    );

    put t.tl, ",", regi.tl, ",", in.tl, ": ";
    put @30 pm_cesdata(t,regi,in,"xi"), " * (";
    put pm_cesdata(t,regi,in,"eff"), " * ";
    put pm_cesdata(t,regi,in,"effGr"), ") ^ ";
    put pm_cesdata(t,regi,out,"rho"), " = ";
    put ( pm_cesdata(t,regi,in,"xi")
        * exp(
            log( pm_cesdata(t,regi,in,"eff")
               * pm_cesdata(t,regi,in,"effGr")
               )
          * pm_cesdata(t,regi,out,"rho")
          )
        ) /;
    sm_tmp = 1;
  );
);

if (sm_tmp,
  put " " /;
  putclose logfile;
  execute_unload "abort.gdx";
  abort "some total efficiencies are too low, see logfile for details";
);
putclose logfile;

***_____________________________ END OF: CONSISTENCY CHECKS ________________________________________

$ONorder

*** Assert that q37_energy_limits is feasible for calibration runs
sm_tmp = 0;
loop ((ttot(t),regi_dyn29(regi),industry_ue_calibration_target_dyn37(out))$(
                                      t.val gt 2015 AND pm_energy_limit(out) ),
  sm_tmp2 = sum(ces_eff_target_dyn37(out,in), pm_cesdata(t,regi,in,"quantity"));
  if (sm_tmp2 le pm_cesdata(t,regi,out,"quantity") * pm_energy_limit(out),
    sm_tmp = 1;
  );
);

$ifthen.subsectors "%industry%" == "subsectors"   !! subsectors
if (sm_tmp eq 1,
  put logfile, "Assertion of industry energy limits failed: " /;
  loop ((regi_dyn29(regi),ttot(t),industry_ue_calibration_target_dyn37(out))$(
                                      t.val gt 2015 AND pm_energy_limit(out) ),
    sm_tmp
    = sum(ces_eff_target_dyn37(out,in), pm_cesdata(t,regi,in,"quantity"));

    if (sm_tmp le pm_cesdata(t,regi,out,"quantity") * pm_energy_limit(out),
      put pm_cesdata.tn(t,regi,out,"quantity"), " * ", pm_energy_limit.tn(out);
      put @80 " = " (pm_cesdata(t,regi,out,"quantity") * pm_energy_limit(out));
      put " > ", sm_tmp /;
      loop (ces_eff_target_dyn37(out,in)$( pm_cesdata(t,regi,in,"quantity") ),
        put @3 pm_cesdata.tn(t,regi,in,"quantity"), @73 " = ";
        put pm_cesdata(t,regi,in,"quantity") /;
      );
      put " " /;
    );
  );
  putclose logfile, " " /;

  execute_unload "abort.gdx";
  abort "Assertion of industry energy limits failed. See .log file for details.";
);
$endif.subsectors

*** EOF ./modules/29_CES_parameters/calibrate/preloop.gms
*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/realization.gms

*' @description
*' The macro-calibration takes place in `modules/29_CES_parameters/calibration/`. The calibration itself is in the file `preloop.gms`.
*'
*' The aim of the calibration is to provide the efficiency parameters of the CES tree for each time step and each region.
*' Efficiency parameters have a strong influence on the level of energy that the CES-tree demands from the energy system module.
*' In order to avoid ad hoc assumptions on the level of these parameters, the new macro-calibration procedure loads exogenous
*' energy demand pathways and ensures that a baseline REMIND run will meet these trajectories.
*'
*' #### How to calibrate Remind
*'
*' This documentation is focused on the implementation. For a practical guide on how to calibrate, refer to the tutorial
*' 'Calibrating CES Parameters' in the `tutorials` folder.
*'
*' #### How the calibration works (Overview)
*'
*' ##### 1. Prerequisites
*'
*' The CES tree in Remind consists of a tree of nested CES production functions of the form
*'
*' $V_o = \left( \sum_{i} \xi_i \left( \theta_i \delta_i V_i \right)^{\rho_o} \right)^{1/\rho_o}$
*'
*' where $V_o$ is the output quantity (`quantity` in the code) with the output node index $o$,
*' $V_i$ are the input quantities with the input node index $i$,
*' $\xi_i$ is the income share (`xi`), $\theta_i$ the efficiency parameter (`eff`),
*' $\delta_i$ is the efficiency growth (`effGr`),
*' and $\rho_o$ (`rho`) is a parameter derived from the substitution elasticity.
*'
*' 'Nested' means that each output of one CES node serves as one of the inputs to the node above, up to the last level.
*' The uppermost level of the tree is GDP (`inco`), the lowest ones (the 'leaves' of the tree) are called primary production
*' factors (`ppf`). They include final energies (`ppfen`), different capital stocks, and labour (`lab`), which is a direct
*' input to `inco`. Consequently, ppf only serve as input to a CES function and there are no CES functions in the tree with
*' ppf as their output. Nodes which are neither ppf nor the top node are called intermdiate production factors (`ipf`).
*'
*' In the following, the term 'efficiency parameters' will be used collectively for the parameters $\xi_i$, $\theta_i$
*' and $\delta_i$ (income share, efficiency and efficiency growth). By combining all three into
*' $\alpha_i = \xi_i \left( \theta_i \delta_i )^{\rho_o}$, the CES function could be simplified to
*'
*' $V_o = \left( \sum_{i} \alpha_i V_{i}^{\rho_o} \right)^{1/\rho_o}.$
*'
*' However, we keep the split into the three components for the following reasons:
*'
*' - We split the efficiency parameter in a time-constant $\xi_i, \thata_i$ and a time-variant $\delta_i(t)$ component to
*'   allow the latter to be controlled endogenously by the model (in module 20_growth/spillover).
*' - The split of the time-constant part into the two components $\xi_i$ and $\theta_i$ is (1) for historic reasons
*'   and (2) allows for easier testing the resulting parameter trajectories in an economic context by checking $\xi_i$
*'   against certain bounds.
*'
*' The derivative of the CES function with respect to one of its input quanities $V_i$  can be calculated as
*'
*' $\frac{\partial V_o(V_1,..., V_i,...,V_n)}{\partial V_i}$
*' $= \xi_i \theta_i \delta_i \ V_o^{1 - \rho_o} \ \left(\theta_i \delta_i V_i\right)^{\rho_o - 1}.$
*'
*' The CES function is a homogenous function of degree one. This entails (following Euler's homogeneous function theorem)
*' that the output is equal to the sum of derivative times quantity of each input
*'
*' $V_o = \sum_{i} \frac{\partial V_o}{\partial V_i} V_i$
*'
*' This motivates to interpret the derivative of $\frac{\partial V_o}{\partial V_i} =: \pi_i$ as the price of $V_i$ in terms
*' of $V_o$. We denote it by $\pi_i$. The output is then equal to the sum of inputs valued at their price, i.e.
*'
*' $V_o = \sum_{i} \pi_i V_i.$
*'
*' ##### 2. Principle
*'
*' In Remind, the elasticities of substitution and thus $\rho$ are prescribed ad-hoc. The quantities $V$ are variables
*' which are optimized in a run (except for labour). The efficiency parameters are determined in the calibration. More
*' precisely,
*'
*' **The calibration adapts the efficiency parameters of the CES function so that precribed target trajectories for all
*'   inputs to the CES tree (FE and capital) and output (GDP, named `inco`) are met.**
*'
*' The target trajectories are usually provided by EDGE models for the different sectors.
*'
*' The calibration works in several iterations, each consisting of one Remind run. In each iteration, the efficiency
*' parameters are adjusted such that the target trajectories are met *with the prices of the primary production factors
*' (ppf) from the previous iteration*. So the two steps of an iteration loop are:
*'
*' 1. The calibration routine determines efficiencies (based on prices of previous iteration)
*' 2. The rest of the remind model run determines optimal ppf prices (given the efficiencies from 1.)
*'
*' Each iteration only differs from the others in the prices that are provided to the calibration. They represent the
*' feedback from the energy system module.
*' The assumption is that by adjusting the efficiency parameters in each iteration, the efficiency parameters and
*' prices converge towards a stable coherent value.
*'
*' #### Steps of the calibration routine
*'
*' The following paragraphs describe the calculations happening in each of the iteration i.e in `preloop.gms`.
*' They can be summarized in five steps:
*'
*' 1. Load CES quantities, calculate prices $\pi_i=\partial V_o / \partial V_i$ from them and propagate via chain rule
*' to get ppf price in terms of GDP $\partial V_{inco} / \partial V_{ppf}$. Set ppf prices $\pi_{ppf}$ to this chain rule
*' product and set all ipf prices to one.
*' 2. Using these prices and the prescribed target quantities $V_{ppf}$, move up CES tree level by level and determine
*' ipf trajectories using $V_o = \sum_{i} \pi_i V_i$.
*' 3. Determine efficiencies such that CES derivatives using target quantities from step 2 yield prices from step 1:
*' $\xi_i = \frac{\pi_i V_i}{V_o}$ and $\theta_i = \frac{V_o}{V_i}$
*' 4. Since GDP is a prescribed CES output quantity, adjust labour price such that all other (target) quantities and
*' prices in that last CES node match; Now that labour price is known, do Step 3 also for labour.
*' 5. Move time-dependent part of $\xi$ and $\theta$ to $\delta$.
*'
*' These steps are now described in more detail.
*'
*' ##### 1. Computation of prices
*'
*' Ppf prices are computed from CES node quantities which are read in from the previous iteration from an `input.gdx` file. In
*' the first iteration, there is no previous iteration, but a file from a previous different run can be used instead, provided
*' that the structure of the CES tree is the same, such that all needed quantities were computed in that previous run.
*'
*' In the first iteration, for a **new** CES tree structure, there is no gdx file from a previous run that could provide
*' directly the CES node quantities needed for calculation of prices. Therefore, exogenous prices must be provided.
*' Switch `cfg$gms$c_CES_calibration_new_structure` to 1 in `config/default.cfg` in case you want to use exogenous prices
*' for the first iteration (If you have a new structure and do not set this switch to 1, you will get an error, as not all
*' necessary prices are found).
*'
*' For other iterations, or if the structure is the one from the `input.gdx`, the equilibrium prices will be computed.
*' They are computed as the derivative *of GDP* in terms of each ppf input:
*' The prices $\pi_i$ are calculated as in the formula obove. They are derivatives of a node with respect to *its direct
*' input nodes* in the level below $\partial V_o / \partial V_i$.
*' What we want, however, is the derivative of GDP (the topmost node) with respect to the ppf (the nodes at the very bottom).
*' So we apply the chain rule: The derivatives of each level of the CES-tree must be multiplied to obtain the desired
*' derivative of GDP w.r.t. ppf.
*' As an example, if one branch of the CES tree is `inco` - `en` - `industry` - `cement` - `eekcement`, then the price
*' of `eekcement` is calculated as
*'
*' $\frac{\partial V_{inco}}{\partial V_{eekcement}}
*'  = \frac{\partial V_{inco}}{\partial V_{en}} \frac{\partial V_{en}}{\partial V_{industry}}
*'    \frac{\partial V_{industry}}{\partial V_{cement}} \frac{\partial V_{cement}}{\partial V_{eekcement}}
*'  = \pi_{en} \pi_{industry} \pi_{cement} \pi_{eekcement}$
*'
*' We do this as a propagation from the top node (`inco`) down the whole tree, where we iteratively calculate each
*' derivative of `inco` as the product of all derivatives above the node, so e.g. we first compute
*' $\frac{\partial V_{inco}}{\partial V_{industry}} = \frac{\partial V_{inco}}{\partial V_{en}}
*'  \frac{\partial V_{en}}{\partial V_{industry}}$
*' and then, using that value, we calculate
*' $\frac{\partial V_{inco}}{\partial V_{cement}} = \frac{\partial V_{inco}}{\partial V_{industry}}
*'  \frac{\partial V_{industry}}{\partial V_{cement}}$,
*' and so on, until we obtain ppf prices on the last level in terms of GDP.
*'
*' Afterwards, the prices of the intermediate production factors (`ipf`) are set to one, since they are now already
*' factored in at the ppf level. Setting ipf prices to one means that the prices $pi_i$ of `ppf` in terms of their
*' direct output correspond to their price in terms of GDP. (In later steps, efficiencies will be adapted to fit
*' these newly prescribed prices.)
*'
*' In a subsequent step, prices are then smoothed in the early years of the model.
*'
*' ##### 2. Calculation of Intermediate Production Factors
*'
*' Ppf quantity target trajectories are given as input to the calibration, but ipf trajectories are not given.
*' We determine them from the equation
*'
*' $V_o = \sum_{i} \pi_i V_i \qquad \forall o \in \text{ipf}$
*'
*' which was derived above. We have calculated all prices and the quantities at ppf level, so we can move up the CES
*' tree level by level from the ppf to compute quantities for ipf.
*' We don't do this for the last level `inco`, as it would yield a trajectory for `income` which differs from the one
*' we prescribed. We will deal with that later.
*'
*' ##### 3. Changing efficiencies to ensure prices are met
*'
*' We have computed prices in step 1 which we precribe. Now we have to ensure that the derivatives of our CES functions
*' are equal to these new prices.
*' We do this by adjusting the efficiencies.
*' We set the efficiency growth to one to simplify the computation. (We will later split this efficiency into a
*' time-constant 2005 efficiency and a time-dependent efficiency growth.)
*' The total efficiency now consists of the two parameters income share $\xi_i$ and efficiency parameter $\theta_i$.
*' Inserting this simplification $\detla_i=1$ into the CES derivative yields
*'
*' $\pi_i = \xi_i \theta_i \ V_o^{1 - \rho_o} \ \left(\theta_i V_i\right)^{\rho_o - 1}$
*'
*' which we can transform to
*'
*' $\xi_i \theta_i^{\rho_o} = \pi_i \frac{V_i}{V_o} \left(\frac{V_o}{V_i}\right)^{\rho_o}$
*'
*' As stated above, the split of the total efficiency into $\xi_i$ and $\theta_i$ is not needed for mathematical
*' reasons. Here, this means that we have to degrees of freedom to fulfill one equation, the system is underdetermined
*' and we have different combinations of $\xi_i$ and $\theta_i$ that fulfill it.
*' We choose
*'
*' - $\xi_i = \frac{\pi_i V_i}{V_o}$
*'   (income share, i.e. share of the value (quantity $\times$ price) of input $i$ ind output $o$) and
*' - $\theta_i = \frac{V_o}{V_i}$ (efficiency, i.e. output $o$ per unit $i$).
*'
*' We use these values to update the efficiencies $\xi_i$ and $\theta_i$ of all nodes except for `lab`.
*'
*' ##### 4. Last level of the CES-tree: Ensure the GDP and Labour trajectories are met
*'
*' The top level (out: GDP; in: Labour, Aggregated Energy and Capital) is a special case: The quantity trajectory of the
*' output `inco` is prescribed exogenously.
*' The quantity trajectories of capital and labour are also prescribed, as they are ppf.
*' From the last steps, we know the quantity and price of energy, as well as the (equilibrium) price of capital.
*'
*' The labour price will be the adjustment variable. So we don't use the equilibrium price from the last iteration for
*' labour, instead we solve the equation
*'
*' $V_o = \sum_{i} \pi_i V_i$
*'
*' for the new price of labour. From this, we can compute the efficiencies for labour as in the step above.
*' (From the information given in this tutorial, switching this step with the previous one would make sense. However, some
*' consistency checks are performed in between, which makes this order necessary.)
*'
*' ##### 5. Calculate Efficiency growth parameter $\delta$
*'
*' The efficiency growth, which was set to one for simplicity, is now re-introduced:
*' For all inputs but capital, the changes over time of $\xi$ and $\theta$ are put into $\delta$. $\xi$ and $\theta$ are
*' thus made constant at their 2005 levels.
*' The efficiency growth parameter captures both the growth in efficiency and in the income share. So, this is the only
*' time-variant parameter.
*'
*' $\delta_i(t) = \frac{\theta_i(t)}{\theta_i(t_0)} \left(\frac{\xi_i(t)}{\xi_i(t_0)}\right)^{1 / \rho_o}$
*'
*' on all CES nodes.
*'
*' #### Extensions and Special cases
*'
*' ##### "Beyond Calib": Calibrating at an intermediary level
*'
*' The CES nest cannot be calibrated on two levels lying one upon the other, as prescribing an additional quantity
*' trajectory would make the equation system over-determined. Recall that we already calibrate to two levels above
*' each other (ppf and inco), but we resolved the over-determined system by introducing the additional degree of
*' freedom of labour price.
*'
*' Currently, in the industry part of the tree, both the subsector outputs (members of
*' `industry_ue_calibration_target_dyn37`)
*' and the ppf are calibrated to. This works in the following way (this documentation is
*' only for the case `c_CES_calibration_industry_FE_target == 1`):
*'
*' The 'main' calibration described above is only carried out down to the UE level. Everything below is left out at
*' first. The part of the tree below UE is then treated in a separate calibration, which follows after the main one
*' in `preloop.gms` under the label `Beyond Calibration`. The same steps as the one above are carried out for this.
*' For this lower part of the tree, the UE are the topmost nodes and the ppfen and ppfkap are the inputs. Since the
*' labour price is missing as an additional degree of freedom to match the trajectroy of the topmost node, a different
*' approach is taken: All ppfen (not ppfkap) input prices are mutliplied with the same factor (the ratio of prescribed
*' to computed UE quantity, minus the ppfkap share), such that the quantity trajectories are met for UE.
*'


*####################### R SECTION START (PHASES) ##############################
$Ifi "%phase%" == "sets" $include "./modules/29_CES_parameters/calibrate/sets.gms"
$Ifi "%phase%" == "declarations" $include "./modules/29_CES_parameters/calibrate/declarations.gms"
$Ifi "%phase%" == "datainput" $include "./modules/29_CES_parameters/calibrate/datainput.gms"
$Ifi "%phase%" == "preloop" $include "./modules/29_CES_parameters/calibrate/preloop.gms"
$Ifi "%phase%" == "bounds" $include "./modules/29_CES_parameters/calibrate/bounds.gms"
$Ifi "%phase%" == "output" $include "./modules/29_CES_parameters/calibrate/output.gms"
*######################## R SECTION END (PHASES) ###############################
*** EOF ./modules/29_CES_parameters/calibrate/realization.gms

*** |  (C) 2006-2024 Potsdam Institute for Climate Impact Research (PIK)
*** |  authors, and contributors see CITATION.cff file. This file is part
*** |  of REMIND and licensed under AGPL-3.0-or-later. Under Section 7 of
*** |  AGPL-3.0, you are granted additional permissions described in the
*** |  REMIND License Exception, version 1.0 (see LICENSE file).
*** |  Contact: remind@pik-potsdam.de
*** SOF ./modules/29_CES_parameters/calibrate/sets.gms

Sets

cesParameter   "parameters of the CES functions and for calibration"
/
  quantity          "quantity of CES function input/output"
  price             "price of CES function input/output"
  eff               "baseyear efficiency of CES function input/output"
  effgr             "multiplicative efficiency growth of CES function input/output"
  rho               "CES function elasticity parameter rho = 1 - (1 / sigma)"
  xi                "baseyear income share of CES function input/output"
  offset_quantity   "quantity offset for the CES tree if the quantity is null"
  compl_coef        "coefficients for the perfectly complementary factors"
/

regi_dyn29(all_regi)   "dynamic region set for compatibility with testOneRegi"
ces_29(all_in,all_in)   "calibration CES tree structure"
ces2_29(all_in,all_in)   "calibration CES tree structure"
ces_29_load(all_in,all_in) "ces from input.gdx"
regi_29_load(all_regi)    "regional resolution from input.gdx"
ipf_29(all_in)   "calibration intermediate production factors"
ppf_29(all_in)   "primary production factors to calibrate for"
in_29(all_in)    "calibration production factors"
ue_29(all_in) "useful energy variables"
ue_fe_kap_29(all_in) "useful energy items which are the direct output of one FE and one Kap, and which is calibrated to. The CES efficiencies need specific treatment"
in_beyond_calib_29(all_in)  "all factors which are outside of the calibration, including the ones which are ppf_29"
in_beyond_calib_29_excludeRoot(all_in) "all factors which are outside of the calibration, excluding the ones which are ppf_29"
root_beyond_calib_29(all_in) "all factors which operate the junction between the calibrated CES and the CES which is not calibrated"
ppf_beyondcalib_29(all_in)    "all factors which are not part of in_29"
ces_beyondcalib_29(all_in, all_in) "production relationships for the non calibrated CES"
ces2_beyondcalib_29(all_in, all_in) "production relationships for the non calibrated CES"
ipf_beyond_last(all_in) "intermediary factors which are just above the ppf_beyondcalib_29 level"
ipf_beyond_29(all_in)  "all ces intermediary levels whose inputs are in beyond_calib"
ipf_beyond_29_excludeRoot(all_in)  "all ces intermediary levels whose inputs are in beyond_calib, excluding the roots"

te_29_report(all_te)  "set of technologies to report on"
/
  hydro
  ngcc
  ngt
  pc
  dot
  gaschp
  wind
  tnrs
  gastr
  refliq
  biotr
  coaltr
/

*created in order to avoid xi negative in the latest periods. Should not be necessary with post-2100 reasonable FE pathways
t_29(ttot)     "time steps considered in the calibration"
  t_29hist(ttot) "historical periods from 2005 on. Used for setting the efficiencies of FE if calibrated at the UE level"
  t_29hist_last(ttot) "last historical period"
  t_29scen(ttot) "non historical periods in t_29"
  t_29_last(ttot) "last period of the calibration"

pf_eff_target_dyn29(all_in)    "production factors with efficiency target"    / /
pf_quan_target_dyn29(all_in)   "production factors with quantity target"      / /

capUnitType  "Type of technological data: for investments or for the standing capital"
/
  cap   "estimate for the standing capital (with some depreciation)"
  inv   "estimate for new investments (without depreciation)"
/

index_Nr "index to differentiate data points with identical characteristics"
/
  0 * 62
/

eff_scale_par   "parameters for scaling certain efficiencies during calibration"
/
  level
  midperiod
  width
/

  CES_tc(all_in)   "CES tree traversal current node"
  /   /
  CES_tp(all_in)   "CES tree traversal pending nodes"
  CES_ts(all_in)   "CES tree traversal swap node"
  /   /

  in_limit_price_change_29(all_in)   "production factors that have their price changes limited to a factor of two during calibration"
  /
    %cm_in_limit_price_change%
  /
;

alias(cesOut2cesIn_below,cesOut2cesIn_below2);

t_29(ttot) = NO;
t_29(t) = YES;
t_29("2110") = NO;
t_29("2130") = NO;
t_29("2150") = NO;

alias(t_29, t2_29);

t_29hist(ttot) = NO;
t_29hist(t)$(sameAs(t,"2005") OR sameAs(t,"2010") OR sameAs(t,"2015")) = YES;
alias(t_29hist,t_29hist2);

t_29scen(ttot) = NO;
t_29scen(ttot)$t_29(ttot) = YES;
t_29scen(ttot)$t_29hist(ttot) = NO;

$offOrder
 t_29hist_last(ttot) = NO;
 t_29hist_last(t_29hist)$(ord(t_29hist) eq card(t_29hist)) = YES;
 t_29_last(ttot) = NO;
 t_29_last(t_29)$(ord(t_29) eq card(t_29)) = YES;
$onOrder

*** EOF ./modules/29_CES_parameters/calibrate/sets.gms